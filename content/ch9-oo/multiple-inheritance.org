* Multiple inheritance

https://docs.python.org/3.5/tutorial/classes.html#inheritance

** Beobachtung: Reihenfolge der Suche nach Attributen 

** Mehrfache Eltern 

** Syntax


* Method Resolution Order 

** Suche nach richtiger Methode, erste Ideen 

Finde Attribute spezialisierterer Klassen vor denen allgemeinerer Klassen 

** Reihenfolge der Ererbung (local precedence) 

** Unnsinng class B(A, A)



** Linearisierung nötig für Suche 

** Anforderungen an sinnvolle Linearisierung 



*** Monoticity 

wenn neue Klasse ableiten, dann: Otherwise, the innocuous operation of deriving a new class could change the resolution order of methods, potentially introducing very subtle bugs. 

monotonic when the following is true: if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C. 

***  local precedence ordering 

breaking of local precedence ordering since the order in the local precedence list, i.e. the list of the parents of G, is not preserved

** Problem: Nicht alle Fälle linearisierbar 

:-( 

#+BEGIN_SRC python :exports code :results output
class X: pass
class Y: pass
class A(X,Y): pass
class B(Y,X): pass
class C(A, B): pass
#+END_SRC 

#+RESULTS:


** MRO : Regel wie linearisiert wird 

For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively) in the base classes of Base1, and if it was not found there, it was searched for in Base2, and so on.



- C3 algorithm 

- https://www.python.org/download/releases/2.3/mro/


** C3 

the linearization of C is the sum of C plus the merge of the linearizations of the parents and the list of the parents.

*** merge 

take the head of the first list, i.e L[B1][0]; if this head is not in the tail of any of the other lists, then add it to the linearization of C and remove it from the lists in the merge, otherwise look at the head of the next list and take it, if it is a good head. Then repeat the operation until all the class are removed or it is impossible to find good heads. In this case, it is impossible to construct the merge, Python 2.3 will refuse to create the class C and will raise an exception. 



* super und MRO 



* Mixins 

