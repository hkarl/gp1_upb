#+TITLE: Kapitel 4: Funktionen (Teil 1) 
#+INCLUDE: "../template/header.org"

# TODO states: looks like this has to go on main file and cannot be
# included 
#+TODO: TODO(t) | UEBUNG(u) DONE(d)
#+OPTIONS: tasks:todo


* Überblick 

** Dieses Kapitel 

- Wir fassen wiederkehrende Anweisungen zu /*Funktionen*/ zusammen
- Funktionen können /*aufgerufen*/ werden
- An einen Funktionsaufruf kann man /*Argumente*/ übergeben 
- Dieses Kapitel: nur einfache Formen des Aufrufs
  - Wir erweitern diese Konzepte in einem späteren Kapitel 



** Setup 						  :skipslide:nolatex:

Main point here is to set up warnings properly for presentation and to
load tutormagic, so that we can later on use pythontutor for code
animations. 
   
#+BEGIN_SRC  Python 
%load_ext tutormagic
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning, module='.*/IPython/.*')
#+END_SRC







* Wiederkehrende Anweisungen

** Wiederkehrende Anweisungen 

- Angenommen, die gleiche Folge von Anweisungen taucht immer wieder
  auf 
  - Eventuell mit kleinen Variationen
- Beispiele:
  - Mathematische Funktionen ausrechen ($\sin$ etc.)
  - Datei zeilenweise auslesen
  - ... 
- Jedes Mal neu eintippen?
  - Programming by Copy/Paste??

** Funktionen 

- Idee: Wiederkehrende Anweisungen nur ein Mal aufschreiben
- Von verschiedenen Stellen eines Programs aus nutzbar machen
- Gründe:
  - Wiederbenutzung erhöhen
  - Redundanz verringern
  - Zerteilen eines Problems in kleinere Teile 

** Problem zerteilen: Kuchen backen 				   :subslide:


- Mache den Teig
- Mache den Belag 
- Buttere die Form 
- Stelle From in Ofen  

** Problem zerteilen: Kuchen backen 				   :subslide:


- Mache den Teig
  - Wiege das Mehl
  - Wiege den Zucker
  - Trenne die Eier
  - Schlage Eischnee
  - Schlage Eigelb und Zucker
  - ... 
- Mache den Belag 
  - ... 
- Buttere die Form 
- Stelle From in Ofen  

** Problem zerteilen: Programmiertechnik			   :subslide:

- Die meisten Programmieraufgaben sind zu groß, um direkt gelöst zu
  werden
- Stattdessen: Suche eine Aufteilung in kleinere Teile
- Die möglicherweise immer noch zu groß sind
  - Dann diese weiter unterteilen
  - Bis handhabbar 
- Schließlich: Setze die Lösung aus den Einzelteilen zusammen 

Sog. */prodzedurale Dekomposition/*

** Funktionen 

- Teillösungen sind /*Funktionen*/
- Wir müssen uns überlegen:
  - Wie erstellen wir eine neue Funktion?
  - Wie benutzen wir eine vorhandene Funktion? 

* Funktionen definieren 

** Name für Folge von Anweisungen 

Wir brauchen: 
- Einen Namen für eine Folge von Anweisungen -- ein Namensschild 
- Ähnlich wie Zuweisung: Ein Name für einen Wert
  - ~Name = Wert~ 
Also: 
- ~Name für Funktion = Folge von Anweisungen~ ?
- Aber Gleichheitszeichen ~=~ ja schon benutzt?? 


** Neue Anweisung: ~def~ 

Wir brauche eine neue Anweisung: ~def~
- Unsere zweite Anweisung nach ~=~
- Ähnlich: Name, Wert 

** Beispiel für ~def~

#+BEGIN_SRC python
  def meine_funktion():
      x = 42
      y = x/2
      # usw... weitere Anweisungen
#+END_SRC


** ~def~

*** Anweisung zur Definition einer Funktion		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Die Anweisung ~def~ verbindet einen (ggf. neuen) Namen (für eine Funktion) mit
einer Folge von Anweisungen.  

- Der Name /referenziert/ diese
Anweisungsfolge. 
- Durch die Schaffung dieses Namens wird der
Programmzustand geändert. 
- Namen für Funktionen folgen den Syntaxregeln der Namen für
Variable. 

*** Eine Anweisung zur Funktionsdefinition?			  :dropslide:

Wenn Sie mit anderen Sprachen wir C oder Java vertraut sind, wird
Ihnen dies vielleicht seltsam vorkommen: Eine /Anweisung/ definiert
eine Funktion? Eine Anweisung muss durch das Programm doch ausgeführt
werden, damit sie einen Effekt? 

Das ist genau der Fall: die Anweisung ~def~ muss ausgeführt werden,
sonst existiert die Funktion nicht. 





** ~def~: Syntaxregel  (1) 



*** Syntax für ~def~ (Teil 1)				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Der Anweisung ~def~ folgt in der gleichen Zeile 
  - der zu definierende Funktionsname 
  - ein Klammerpaar ~()~
  - und ein Doppelpunkt ~:~ 
- Die Anweisungsfolge kommt in den folgenden Zeilen
  - *eingerückt* um vier Leerzeichen 

*** UEBUNG Eine Zeile für ~def~? 

In vorheriger Übung gelernt: IN klammern darf Zeielumbruch schadlos
erfolgen. Was sagt uns das für die Definition von Funktionen? 

Probieren Sie das in einem Notebook aus! 



** Schlüsselwort: ~def~						   :subslide:

- ~def~ hat offenbar Sonderrolle 
- Als normaler Name benutzbar? 
- *Nein!* 
  - Ein weiteres Schlüsselwort!


** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 


** Einrückung? 

- Durch die Einrückung sind die Anweisungen bestimmt, die mit dem
  Funktionsname verbunden werden
- Ende der Einrückung: Ende der Funktionsdefinition 
- Darauf folgt: Einrückungen wichtig für Struktur
  - Python: Willkürliches Ein-/Ausrücken fehlerhaft! 


** Visuelle Struktur 

- Python-Programme sind durch Einrückungen strukturiert 
- Wir brauchen keine zusätzlichen Strukturelemente
  - Wie beispielsweise Klammern ~{~ oder ~}~ 

- Kompakte, leicht zu lesende Ausdrucksweise! 


** Einrückung: Beispiel 

#+BEGIN_SRC python
  %%tutor 
  def f():
      x = 5
      y = 17
      # weitere Anweisungen

  # Definition von f zu Ende!

  def g():
      a = 1
      b = a+1
      # usw

  # Definition von g zu Ende!
  z = 42
#+END_SRC


*** UEBUNG Leerzeichen? Tabs? 

Was sagt PEP8 dazu? 

Klar machen: das macht ein Editor sowieso 


** Visualisierung: Was passiert? 

- Beim Ablauf des obigen Beispiels: *drei* Anweisungen ausgeführt!
  1. Die Definition von ~f~ und Herstellung der Referenz auf
     Anweisungen
  2. Entsprechend: die Definition von ~g~
  3. Die Zuweisung ~z = 42~ 
- Zustand des Programms: Namen ~f~, ~g~ und ~z~ referenzieren Werte 

*** Zustand nach Funktionsdefinition				  :dropslide:

Abbildung [[fig:zustand-f-g-z]] stellt den Zustand nach der Definition von
~f~ und ~g~ dar. 

#+CAPTION: Zustand nach Definition von ~f~, ~g~ und Zuweisung an ~z~
#+ATTR_LaTeX: :width 0.75\linewidth :float nil
#+NAME: fig:zustand-f-g-z
[[./figures/frame-f-g-z.png]]


** Starke Analogie: Variablename, Funktionsname 

- Die Analogie zwischen Zuweisung und Funktionsdefinition ist sehr eng! 

- Funktionsnamen benehmen sich nahezu identisch zu Variablennamen 

- Aber Notation doch recht unterschiedlich? 

*** Unterschiedliche Notation für Variablen und Funktionen?	  :dropslide:

Das hat letztlich pragmatische und auch Geschmacksgründe. Tatsächlich
gibt es Programmiersprache (etwas Lisp), bei denen diese Analogie noch
viel enger ist und auch in der Syntax kaum ein Unterschied in der
Definition einer Variabler  oder eines Funktionsnamens liegt. 

** Sprechweise: Objekt 

- Wir haben Namen für Werte, für Folgen von Anweisungen, usw.  
- Das wird unübersichtlich!

*** Verallgemeinerung: Objekt					    :animate:

- Verallgemeinern wir die Sprechweise: Objekte
  - Wenn es auf die Unterscheidung nicht ankommt
  - Werte sind Objekte
  - Folgen von Anweisungen sind Objekte
  - ... 
- Wir haben: Namen für /*Objekte*/ 


** ~def~ definiert ein Objekt 

- Damit Analogie zwischen ~=~ und ~def~ noch enger
  - Eine Zuweisung ~=~ erzeugt ein Objekt und bindet den Namen daran
    - Das Objekt ist hier der Wert 
  - Eine Funktionsdefinition erzeugt ein Objekt und bindet den Namen
    daran
    - Das Objekt ist hier die Folge von Anweisungen 

- Funktionen (=Folge der Anweisungen) benehmen sich nur wenig anders
  als normale Werte! 


* Aufruf 

** Aufruf einer Funktion 

- Funktionsfolgen mit Namen versehen: Toll!
- Aber wie Nutzen? 
- Genauer: Wie dafür sorgen, dass die Anweisungen einer Funktion an
  einer Stelle im Programm ausgeführt werden?
  - Ein /Funktionsaufruf/ durchführen 

** Aufruf einer Funktion: Syntax 

- Einfache Syntax: Den Funktionsnamen und ein Klammerpaar hinschreiben
- Als Teil eines Ausdrucks 
- Beispiel: 

#+BEGIN_SRC python
  %%tutor -t 
  def f():
      x = 42
      y = 17

  # hier wird aufgerufen
  z = "vorher"
  f()
  z = "nachher"
#+END_SRC


** Aufruf einer Funktion: Semantik  

Wir erweitern das Ausführungsmodell:

*** Aufruf einer Funktion: Semantik (v1) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
  - Vorstellung: Der Aufruf der Funktion wird durch die Anweisungen
    der Funktion ersetzt, und dann wird ausgeführt 
- Nach Ausführung der letzten Anweisung der Funktion: Mit der
  Anweisung nach dem Aufruf weitermachen 

** Aufruf einer Funktion: Semantik  

*** Das ist nur eine erste Vorstellung			       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Die Definition hier ist unvollständig und nicht ganz korrekt. Wir
brauchen dazu noch ein paar Erweiterungen! 



*** UEBUNG WArum sit das nur eine grobe Entsprechung

Wo sind die Unterschied? Zumindest einer klar: Im Zustand fehlt der
Eintrag für den Funktionsnamen f . Und die Variablen x und y sind
nicht im Scope. 

** Variablen: Scope 

- Was passiert mit ~x~ und ~y~ aus der Funktion?
- Verschwinden nach Rückkehr aus der Funktion! 

*** Lebensdauer? 						    :animate:

- Variable, an die innerhalb einer Funktion zugewiesen
  wird, ist *lokal* zu dieser Funktion
  - Existiert nur, solange Anweisungen dieser Funktion ausgeführt
    werden
  - Verschwindet nach Ende der Funktion 


** Scope und Frame 

***  ~Scope und Frame~					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Der /Scope/ einer Variable sind die Zeilen des Programms, in denen auf
diese Variable zugegriffen werden kann. 

Der /Frame/ einer Funktion fasst die Scopes der Variablen der Funktion
 zusammen. Er enthält alle Variablen, die die Funktion selbst erzeugt
 hat und auf die sie zugreifen kann. 

Mit dem Ende der Funktion wird der Frame vernichtet. Damit endet der
Scope der enthaltenen Variabeln (sie sind /out of scope/). 


*** Anmerkung						   :B_note:dropslide:
    :PROPERTIES:
    :BEAMER_env: note
    :END:


Das stimmt nicht ganz. Wir werden diese Definition in folgenden
Kapiteln noch verfeinern. 

** Scope/Frame: Beispiel 

#+BEGIN_SRC python
  %%tutor -t
  def f():
      x = 42
      y = 17

  z = "vorher"
  f()
  z = "dazwischen"
  f()
  z = "danach" 
#+END_SRC


*** Unterschiedliche Scopes					  :dropslide:

Die folgenden Abbildungen zeigen die unterschiedlichen Scopes. In der
Pythontutor-Anzeige werden dabei auf der rechten Seite die Frames
separat angezeigt: 

- Ein /global frame/: Die Namen, die im aufrufenden Teil des Programms
  bekannt sind.
- Der frame für die Funktion ~f~: Namen, die nur innerhalb von ~f~
  bekannt sind und die danach wieder verschwinden. 


In den einzelnen Schritten geschieht folgendes: 

1. Nach Definition von ~f~, vor dem ersten Aufruf (Abbildung
   [[fig:pt-vor-f1]]): hier sind lediglich die Namen ~z~ und ~f~
   bekannt. Der Aufruf von ~f~ wird als nächstes ausgeführt werden.
#+CAPTION: Aufruf einer Funktion, Scopes: Vor erstem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-vor-f1
[[./figures/pt-f-1-vorf.png]]
2. [@2] Innerhalb des ersten Aufrufs von ~f~ (Abbildung [[fig:pt-in-f1]]): Kurz vor
   Ende von ~f~ sind die beiden Namen ~x~ und ~y~ bekannt, die lokal
   innerhalb der Funktion eingeführt wurden. Achten Sie darauf, dass
   diese Namen in einem anderen Scope -- dem von ~f~ -- existieren.
#+CAPTION: Aufruf einer Funktione, Scopes: Im ersten Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-in-f1
[[./figures/pt-f-2-inf1.png]]
3. [@3] Nach Abschluss des ersten Aufrufs von ~f~, vor dem zweiten
   (Abbildung [[fig:pt-zwischen-f]]): Achten Sie darauf, dass der Scope von
   ~f~ nicht mehr existiert und damit auch die beiden Namen ~x~ und
   ~y~ verschwunden sind (ebenso wie die Werte, die von ~x~ und ~y~
   referenziert wurden -- es gibt ja keinen Namen mehr, unter denen
   man sie finden könnte). Es existieren jetzt lediglich die schon
   vor dem Aufruf bekannten Namen ~z~ und ~f~. ~z~ referenziert
   inzwischen einen anderen Wert, nämlich die Zeichenkette
   /dazwischen/.
#+CAPTION: Aufruf einer Funktion, Scopes: Nach erstem Aufruf, vor zweitem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-zwischen-f
[[./figures/pt-f-3-dazwischen.png]]
4. [@4] Wir sind im zweiten Aufruf von ~f~ (Abbildung [[fig:pt-inf2]]). Das
   erkennen Sie in diesem Beispiel an dem Wert von ~z~ im globalen
   Scope; aus den Pfeilen für die auszuführende Instruktion ist das
   nicht ersichtlich -- die zeigen ja lediglich auf die aktuelle
   Stelle. Die (neu geschaffenen) Namen ~x~ und ~y~ regenerieren die
   gleichen Werte wie oben (die ebenfalls neu geschaffen wurden).
#+CAPTION: Aufruf einer Funktion, Scopes: Im zweiten Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-inf2
[[./figures/pt-f-4-inf2.png]]
5. [@5] Nach dem der zweite Aufruf von ~f~ abgeschlossen wurde (Abbildung
   [[fig:pt-nach-f]]) sind wieder die beiden Namen (samt referenzierter
   Werte) ~x~ und ~y~ verschwunden. Der Name ~z~ zeigt auf den neuen
   Wert. 
#+CAPTION: Aufruf einer Funktion, Scopes: Nach zweitem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-nach-f
[[./figures/pt-f-5-danach.png]]



** Funktionen haben keinen Effekt? 

- Wenn die Variablen der Funktion nach Ende der Funktion vernichtet
  werden -- dann hat eine Funktionsausführung doch gar keinen Effekt?
  - Oder: Verändert den Zustand nicht?

#+CAPTION: Funktionen ohne Effekt?
#+ATTR_LaTeX: :width 0.25\linewidth
#+NAME: fig:calvin-facepalm
[[./figures/facepalm.png]]


** Funktionen ohne Effekt: Beispiel 

Was ist der Wert von ~x~ am Ende? 

#+BEGIN_SRC python
  %%tutor
  def f():
      x = 42

  # rufe f auf:    
  f()
  # greife auf x zu:
  x
#+END_SRC


* Rückgabewert 
** Rückgabewert 
- Benötigt: Mechanismus, um Wert aus Funktion an den aufrufenden
  Programmteil zu transportieren
  - Geht nicht in normaler Variable 


** Neue Anweisung: ~return~

*** ~return~-Anweisung					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:
- Die Anweisung ~return~ erlaubt, einen beliebigen Wert aus einem 
  Funktionsaufruf an den aufrufenden Teil zu transportieren
  - Auf ~return~ darf ein beliebiger Ausdruck folgen
  - Des Wert wird /zurückgegeben/
- ~return~ ist ein Schlüsselwort 

*** Beobachtung							    :animate:

- Ausführungsmodell erweitert! 


** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 
- ~return~ 


** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v2) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
  - Vorstellung: Der Aufruf der Funktion wird durch die Anweisungen
    der Funktion ersetzt, und dann wird ausgeführt
- Bei der Ausführung einer Funktion wird ein neuer Scope für die
  Variablen der Funktion angelegt
  - Dieser Scope wird nach Ende der Funktion wieder vernichtet 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~ 

** Funktion mit ~return~: Beispiel 

#+BEGIN_SRC python
  %%tutor -t
  def pi():
      return 3.14159296

  x = pi()
#+END_SRC


*** Erläuterung							  :dropslide:

Was geschieht bei der Ausführung dieses kleinen Programms? Betrachten
wir drei Schritte: 

1. Unmittelbar vor dem Aufruf der Funktion ~pi~ (Abbildung [[fig:pt-pi-vor]]) ist als
   einziger Name der Funktionsname ~pi~ bekannt. Die nächste
   auszuführende Anweisung ist der Aufruf.
#+CAPTION: Vor dem Aufruf der Funktion ~pi~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-vor
[[./figures/pt-pi-1.png]]
   
2. [@2] Nach dem Aufruf und nach der Ausführung der Anweisung ~return~
   (Abbildung [[fig:pt-pi-return-value]]) wird im Scope von ~pi~ eine
   /scheinbare/ Variable ~return value~ angelegt. Diese Variable zeigt
   auf den Wert des Ausdrucks, den ~return~ bearbeitet. Wie jede
   andere Variable im Scope einer Funktion wird auch diese Variable
   nach Rückkehr vernichtet. 
#+CAPTION: Nach Berechnung des Rückgabewerts, Anlegen der scheinbaren Variable ~return value~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-return-value
[[./figures/pt-pi-2.png]]

3. [@3] Aber der /*Wert*/ dieser scheinbaren Variable bleibt bei der
   Rückkehr aus der Funktion erhalten! Dieser Wert wird wie ein ganz
   normaler Wert weiterverwendet (es /ist) ein ganz normaler
   Wert). Dieser Wert /ersetzt/ den Aufruf von ~pi~ in dem Ausdruck,
   in dem der Ausdruck vorkam. 

   Im Beispiel hier ist das die Zuweisung an die Variable ~x~. Als
   Effekt stellt sich ein: ~x~ wird zu einem Namen für den Wert, den
   die Funktion ~pi~ mit der Anweisung ~return~ angegeben hat. 

#+CAPTION: Nach Ersetzung des Funktionsaufrufs durch den Rückgabewert, Zuweisung an ~x~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-danach
[[./figures/pt-pi-3.png]]


Anmerkung: Die tatsächliche technische Realisierung innerhalb eines
Python-Interpreters funktioniert so ähnlich, allerdings mit ein paar
Abweichungen im Detail. 

** Funktion ohne ~return~? 

Was passiert, wenn eine Funktion keine ~return~ Anweisung hat? 

#+BEGIN_SRC python
  %%tutor
  def no_return():
      x = 17
      y = 42*x

  z = no_return()
#+END_SRC


** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v3) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
- Bei der Ausführung einer Funktion wird ein neuer Scope für die
  Variablen der Funktion angelegt
  - Dieser Scope wird nach Ende der Funktion wieder vernichtet 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~
  - Fehlt ein expliziter Rückgabewert, so nimm ~None~ als besonderen
    Wert an

** Funktion mit leerem ~return~

Ein ~return~ ohne Ausdruck? 

#+BEGIN_SRC python
  %%tutor
  def empty_return():
      x = 17
      y = 42*x
      return 

  z = empty_return()
#+END_SRC



** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 
- ~return~ 
- ~None~
  - ~None~ wird sich an vielen Stellen als praktisch erweisen, um das
    Fehlen eines eigentlich sinnvollen Wertes darzustellen
  - Achtung: ~None~, nicht ~none~! 


* Parameter 

  
** Funktionen bis jetzt: Langweilig

- Unsere Funktionen machen immer das gleiche 
- Nur nützlich, wenn wirklich /identischer/ Code mehrfach in einem
  Programm vorkäme
- Flexibler?
  - Funktion in Mathematik: Abbildungen von Werten auf Werte

- Parameter! 

** Funktion mit Parameter: Idee 

- Funktionen können ja Variablen benutzen
  - Sind innerhalb des Scopes der Funktion
  - Funktion weist Werte zu 
- Wie wäre es, wenn Variablen der Funktion /*von außen*/ mit Werten
  versorgt werden könnten?
  - Normale Variable im Scope der Funktion
  - Aber der Wert wird durch aufrufenden Programmteil festgelegt? 


** Funktion mit Parameter: Syntax der Definition 

- Wir machen Anleihe bei mathematischer Notation
- Zu belegende Variablennamen werden in Klammern nach Funktionsname
  angegeben
  - Der sog. /formale Parameter/ 
- Beispiel: 

#+BEGIN_SRC python
  # Eine Funktion f mit formalem Parameter a 
  def f(a):
      # In Funktion: a ist ganz normale Variable
      return a+1
#+END_SRC


** Funktion mit Parameter: Aufruf 

- Wie ruft man eine solche Funktion auf? 
  - Wie legt man den Wert für den formalen Parameter fest? 
- Einfach: bei Aufruf, in Klammern angeben
  - Der /übergebene Wert/, der /tatsächliche Wert/, das /Argument/,
    der /actual parameter/

#+BEGIN_SRC python
  %%tutor
  def f(a):
      return a+1

  x = f(2)
#+END_SRC


** Funktion mit Parameter: Semantik des Aufrufs 

- Semantik: Formaler Parameter wird zu Namen für den übergebenen Wert 

*** Literal als Argument					  :dropslide:

In diesem ersten Beispiel übergeben wir einen festen Wert an eine
Funktion mit einem Parameter. Dazu wird zunächst dieser Wert -- im
Beispiel die Zahl 2 -- erzeugt. Der formale Parameter wird im Moment
des Aufrufs zur Referenz für diesen Wert.  (Wie sollte es auch anders
funktionieren, wenn man Variablen als Namen für Werte auffasst?)
Abbildung [[fig:pt-fa-wert]] illustriert das. 

#+CAPTION: Formaler Parameter ist Name für übergebenen Wert
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-wert
[[./figures/pt-fa.png]]


** Funktion mit Parameter: Aufruf mit Ausdruck 

- Vorheriges Beispiel: Fester Wert übergeben 
- Geht das auch mit Ausdruck? 


#+BEGIN_SRC python
  %%tutor
  def f(a):
      return a+1

  x = f(2+2)
#+END_SRC


*** Ausdruck als Argument					  :dropslide:

Wenn wir einen Ausdruck übergeben, so passiert ebenfalls das
Naheliegende: Der Wert des Ausdrucks wird bestimmt und erzeugt. Dann
wird der formale Parameter zum Namen für diesen Wert. Siehe
Abbildung [[fig:pt-fa-ausdruck]]. 

#+CAPTION: Formaler Parameter ist Name für Wert eines übergebenen Ausrucks
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-ausdruck
[[./figures/pt-fa-ausdruck.png]]


** Funktion mit Parameter: Aufruf mit Variable

- Was, wenn Variable an Funktion übergeben wird? 
- Wie bisher! Formaler Parameter ist Name des /Wertes/


#+BEGIN_SRC python
  %%tutor
  def f(a):
      return a+1

  y = 5
  x = f(y)
#+END_SRC


*** Variable als Argument					  :dropslide:


Auch wenn eine Variable an eine Funktion übergeben wird, passiert
wieder genau das gleiche: der formale Parameter wird zu einem (hier:
weiteren) Namen für den übergebenen Wert. Abbildung [[fig:pt-fa-y]] zeigt
deutlich: ~a~ und ~y~ sind beides Referenzen auf den gleichen Wert. 

#+CAPTION: Formaler Parameter ist Name für Wert einer Variablen 
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-y
[[./figures/pt-fa-y.png]]

**** Formale Parameter werden NICHT zu Namen für Variablen     :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:

 Hier gilt ähnliches wie bei der Zuweisung: der formale Parameter ist
 ein Name für den /Wert/. Ein formaler Parameter kann kein Name für
 einen anderen Namen sein. 


*** UEBUNG Und f(y+2) 

animieren lassen, erklären was passiert 


** Zuweisung an formale Parameter? 

- Was geschieht, wenn Funktion Wert an formalen Parameter zuweist?
  - Wert von ~y~ am Ende? 

#+BEGIN_SRC python
  %%tutor
  def f(a):
      a = a+1
      return a

  y = 5
  x = f(y)
#+END_SRC

*** Was immer geschieht!					    :animate:

- Die Variable ~a~ wird zu einem Namen für den neuen Wert 
- Warum sollte sich dadurch an der Variable im Aufruf  etwas ändern??


*** Zuweisung an formale Parameter -- Einzelschritte 		  :dropslide:


Im einzelnen geschieht hier genau die zu erwartende Folge von
Einzelschritten. Beim Aufruf wird ~a~ zunächst zu einem (zweiten)
Namen für den Wert 5 (Abbildung [[fig:pt-fa2-vor]]). Nach der Zuweisung
wird ~a~ zu einem Namen für einen anderen Wert (Abbildung
[[fig:pt-fa2-nach]]). Dies beeinflusst nicht die Tatsache, dass ~y~ ein
Name für den Wert 5 ist.


#+CAPTION: Zuweisung an formalen Parameter in Funktion: Vor der Zuweisung
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa2-vor
[[./figures/pt-fa2-1.png]]

#+CAPTION: Zuweisung an formalen Parameter in Funktion: Nach der Zuweisung
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa2-nach
[[./figures/pt-fa2-2.png]]


*** UEBUNG Was passiert, wenn formaler Parameter und Argument gleichen Variabelennamen haben?  

Überlegen, Scope verstehen, animation ? 


** Aufrufsemantik: Pass-by-assignment  

- Formal ist die Aufrufsemantik von Python ein
  sog. /Pass-by-assignment/ 
  - Den formale Parametern werden Werte der Argumente zugewiesen 

*** Unterschied zu anderen Sprachen			   :B_note:dropslide:
    :PROPERTIES:
    :BEAMER_env: note
    :END:

Wenn Sie mit anderen Sprachen (C oder C++) vertraut sind: Dies klingt
nach call-by-reference, ist aber nicht genau das gleiche. Wir kommen
darauf noch zurück. 



** Funktion mit mehreren Parametern: Syntax 

- Mehrere Variablen: Aufzählung, durch Komma getrennt
  - Ähnlich wie bei Zuweisung 
- Beispiel: 


#+BEGIN_SRC python
  def f(a, b, c):
      # In Funktion: a, b, c sind ganz normale Variablen
      return a+b*c

  # Aufruf:
  f(1, 2, 3)
#+END_SRC


** Funktion mit Parametern: Syntax allgemein  

Eine Funktion kann eine beliebige Anzahl an Parametern haben: 

#+BEGIN_SRC python 
  def f(arg1, arg2, ..., argN):
      # Folge von Anweisungen
      ... 
      ... 
      # Optional, aber oft sinnvoll:
      return Rueckgabewert
#+END_SRC


** Funktion mit mehreren Parametern: Semantik 

- Pass-by-assignment wird auf alle formalen Parameter separat
  angewandt
- Genauer:
  - Die /Werte/ aller Argumente werden bestimmt
  - Die formalen Parameter werden zu Namen für diese Werte 
  - Ganz analog zur Mehrfachzuweisung!

*** UEBUNG Auswertungsreihenfolge? Macht das einen Unterschied? Wann würde es Unterschied machen? 

** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v4) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
- Bei der Ausführung einer Funktion wird ein neuer Scope für die
  Variablen der Funktion angelegt
- Formale Parameter sind Variablen in diesem Scope; sie sind Namen für
  die Werte der beim Aufruf übergebenen Argumente 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~
  - Fehlt ein expliziter Rückgabewert, so nimm ~None~ als besonderen
    Wert an



* Seiteneffekt 

** Besondere Funktionen: Beispiel ~print~

Aufruf einer /vordefinierten/ Funktion: 

#+BEGIN_SRC python
print("Hallo GP1")
x = 42
print (x)
#+END_SRC

** ~print~: Seiteneffekt 

~print~ ist Beispiel für eine Funktion mit einem /Seiteneffekt/ 

*** Seiteneffekt					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:


Ein /Seiteneffekt/ (Wirkung, side effect) ist eine Aktivität des
Programms, die 
- /außerhalb/ des Programms (oder Programmteils) eine Wirkung hat
- aber den /Zustand/ des Programms (Programmteils) /nicht/ verändert. 

** Seiteneffekt von ~print~ 

Bei ~print~: 
- Gib den Wert des Arguments aus
- Wohin? Auf die /Standard-Ausgabe/
  - Bei Jupyter: Wird unterhalb der Zelle angezeigt
  - Allgemein: Je nach Ausführungskontext  (Terminal, ...) 


*** Seiteneffekt und funktionale Sprachen 			  :dropslide:

Mit dieser Definition läßt sich eine funktionale Programmiersprache
einfach definieren: Eine Sprache in der es keine Seiteneffekte
gibt. 

Mehr dazu in GPS. 


*** UEBUNG print bei strings mit escape sequenzen 

Unterschied klarmachen und ausprobieren: 

#+BEGIN_SRC 
s1 = "c:\documents\bla.txt"
print(s1)
s1
#+END_SRC

bzw. 

#+BEGIN_SRC 
s1 = r"c:\documents\bla.txt"
print(s1)
s1
#+END_SRC


*** UEBUNG print von triple-quotes 

Ähnlich wie davor; aber jetzt triple quoted strings. Wie ist das mit
Einrückung? 



* Randbemerkungen, Zusammenfassung  

** Funktionen finden 

Wo gibt es Funktionen? 

- Selbst geschrieben 
- Eingebaut, z.B. ~print~
  - Siehe [[https://docs.python.org/3/library/functions.html][Liste der eingebauten Funktionen]]
- In ~Modulen~, zusammengestellt zu ~Bibliotheken~ -- siehe später 

** Eingebaute Funktionen, weitere Beispiele 

*** ~type~

#+BEGIN_SRC python
  type(42)
  type(0.01)
  type("Hallo GP1")
#+END_SRC


*** ~max~ 

#+BEGIN_SRC python
max(1, 2, 3)
#+END_SRC


*** UEBUNG Beispiele fuer Ubeungen 

- chr()
- abs()
- complex()
- divmod()
- float() float("17.2")
- help()
- max(), min()
- len() für string
  - wie ist das mit unicode strings? Was gibt len hier aus? 



** Funktionen und Stil 

Wie schreibt man Funktionen stilsicher?  (PEP8)

- Namen: klein, mit ~_~
  - Kein CamelCase
- Leerzeichen:
  - Keine zwischen ~funktionsname~ und ~(~
    - Nicht bei Definition, nicht bei Aufruf
  - Keine nach öffnender Klammer 
  - Nach Komma (wie üblich) 


** Kommentare 

*Konvention*: Jede Funktion mit einem ~docstring~ versehen
- ~docstring~ : Die erste Anweisung in einer Funktion ist eine Zeichenkette
- Erläutert Zweck und Nutzung der Funktion 
- Details: [[https://www.python.org/dev/peps/pep-0257/][PEP 257]]

Konvention verletzt?  
- Programmierwerkzeuge versagen 
- Beispiel: [[http://docutils.sourceforge.net][docutils]]


** ~docstring~ 

- Kurzversion, eine Zeile
  - Befehlsform, beschreibe den Effekt der Funktion
  - Nicht die Parameter der Funktion wiederholen; das ist
    offensichtlich 
  - ~"""Kommentiere Deine Funktionen ordentlich."""~
- Langversion, mehrere Zeilen
  - Anfang wie bei einer Zeile
  - Dann Parameter aufzählen und /Zweck/ beschreiben
  - Ggf. Rückgabewert 

** ~docstring~: Beispiel 

#+BEGIN_SRC python

def complex(real, imag):
    """Form a complex number.

    Keyword arguments:
    real -- the real part
    imag -- the imaginary part
    """

    # Und hier würden Anweisungen folgen 
#+END_SRC


*** UEBUNG Beispoiele für docstrings schreiben lassen 

Funktionen vorgeben... 


** Kommentare sind Kommunikation 

#+CAPTION: Kommentare sind Kommunikation, möglicherweise mit sich selbst 
#+ATTR_LaTeX: :width 0.25\linewidth :float nil
#+NAME: fig:comments-communication
[[./figures/future_self.png]]



** Zusammenfassung 

- Die gleichen Anweisungsfolgen wiederholen sich oft in Programmen
- Zur einfachen Wiederverwendungen führen wir Funktionen ein
  - Werden von einem oder mehreren Teilen des Programms /aufgerufen/
- Interagieren mit aufrufendem Teil durch
  - /formale Parameter/, die beim Aufruf mit  /Argumenten/ versehen
    werden
  - /Rückgabewert/, der die Stelle des Funktionsaufrufs einnimmt
- Formale Parameter werden zu Namen für die Werte der Argumente
- Manchmal: /Seiteneffekte/ 
- Objekt: Verallgemeinert Sprechweise



* IM zweiten Teil						   :noexport:


- Rücksprungadresse? oder schon hier? 
- geschachtelte Funktionsdefinition 
- Module
- Scopes
- Funktionsdefinition in if statements 
- lambda 
- yield 
