#+TITLE: Kapitel 4: Funktionen, Teil 1
#+INCLUDE: "../template/header.org"

#+STARTUP: showeverything

# TODO states: looks like this has to go on main file and cannot be
# included 
#+TODO: TODO(t) | UEBUNG(u) DONE(d)
#+OPTIONS: tasks:todo

#+LATEX_HEADER: \setcounter{chapter}{4}

* Überblick 

** Dieses Kapitel 

- Wir fassen wiederkehrende Anweisungen zu /*Funktionen*/ zusammen
- Funktionen können /*aufgerufen*/ werden
- An einen Funktionsaufruf kann man /*Argumente*/ übergeben 
- Dieses Kapitel: nur einfache Formen des Aufrufs
  - Wir erweitern diese Konzepte in einem späteren Kapitel 



** Setup 						  :skipslide:nolatex:

Main point here is to set up warnings properly for presentation and to
load tutormagic, so that we can later on use pythontutor for code
animations. 
   
#+BEGIN_SRC  Python 
%load_ext tutormagic
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning, module='.*/IPython/.*')

import requests
import webbrowser
from IPython.core.magic import register_line_magic

pingo_token = "BRx9QJP7rjdUGBq3x4hP"

# Test-Session: 
pingo_url = "https://pingo.upb.de/events/311055/quick_start.json"
# Produktiv-Session: 
# pingo_url = "https://pingo.upb.de/events/204051/quick_start.json"

pingo_duration = '30'
pingo_type = "single"


@register_line_magic
def pingo(line):
    params = {'survey_name': pingo_title, 
              'predef_options': pingo_questions, 
              'q_type': pingo_type,
              'duration': pingo_duration, 
              'auth_token': pingo_token}

    r = requests.post(pingo_url, json=params)
    webbrowser.open_new_tab("https://pingo.upb.de" + r.headers['Location'])
#+END_SRC







* Wiederkehrende Anweisungen

** Wiederkehrende Anweisungen 

- Angenommen, die gleiche Folge von Anweisungen taucht immer wieder
  auf 
  - Eventuell mit kleinen Variationen
- Beispiele:
  - Mathematische Funktionen ausrechnen ($\sin$ etc.)
  - Datei zeilenweise auslesen
  - ... 
- Jedes Mal neu eintippen?
  - Programming by Copy/Paste??

** Funktionen 

- Idee: Wiederkehrende Anweisungen nur ein Mal aufschreiben
- Von verschiedenen Stellen eines Programs aus nutzbar machen
- Gründe:
  - Wiederbenutzung erhöhen
  - Redundanz verringern
  - Zerteilen eines Problems in kleinere Teile 

** Problem zerteilen: Kuchen backen 				   :subslide:


- Mache den Teig
- Mache den Belag 
- Buttere die Form 
- Stelle Form in Ofen  

** Problem zerteilen: Kuchen backen 				   :subslide:


- Mache den Teig
  - Wiege das Mehl
  - Wiege den Zucker
  - Trenne die Eier
  - Schlage Eischnee
  - Schlage Eigelb und Zucker
  - ... 
- Mache den Belag 
  - ... 
- Buttere die Form 
- Stelle Form in Ofen  

** Problem zerteilen: Programmiertechnik			   :subslide:

- Die meisten Programmieraufgaben sind zu groß, um direkt gelöst zu
  werden
- Stattdessen: Suche eine Aufteilung in kleinere Teile
- Die möglicherweise immer noch zu groß sind
  - Dann diese weiter unterteilen
  - Bis handhabbar 
- Schließlich: Setze die Lösung aus den Einzelteilen zusammen 

Sog. */prodzedurale Dekomposition/*

** Funktionen 

- Teillösungen sind /*Funktionen*/
- Wir müssen uns überlegen:
  - Wie erstellen wir eine neue Funktion?
  - Wie benutzen wir eine vorhandene Funktion? 

* Funktionen definieren 

** Name für Folge von Anweisungen 

Wir brauchen: 
- Einen Namen für eine Folge von Anweisungen -- ein Namensschild 
- Ähnlich wie Zuweisung: Ein Name für einen Wert
  - ~Name = Wert~ 
Also: 
- ~Name für Funktion = Folge von Anweisungen~ ?
- Aber Gleichheitszeichen ~=~ ja schon benutzt?? 


** Neue Anweisung: ~def~ 

Wir brauche eine neue Anweisung: ~def~
- Unsere zweite Anweisung nach ~=~
- Ähnlich: Name, Wert 

** Beispiel für ~def~

#+BEGIN_SRC python
  def meine_funktion():
      x = 42
      y = x/2
      # usw... weitere Anweisungen
#+END_SRC


** ~def~

*** Anweisung zur Definition einer Funktion		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Die Anweisung ~def~ verbindet einen (ggf. neuen) Namen (für eine Funktion) mit
einer Folge von Anweisungen.  

- Der Name /referenziert/ diese Anweisungsfolge. 
- Durch die Schaffung dieses Namens wird der Programmzustand geändert. 
- Namen für Funktionen folgen den Syntaxregeln der Namen für Variable. 

*** Eine Anweisung zur Funktionsdefinition?			  :dropslide:

Wenn Sie mit anderen Sprachen wie C oder Java vertraut sind, wird
Ihnen dies vielleicht seltsam vorkommen: Eine /Anweisung/ definiert
eine Funktion? Eine Anweisung muss durch das Programm doch ausgeführt
werden, damit sie einen Effekt hat? 

Das ist genau der Fall: die Anweisung ~def~ muss ausgeführt werden,
sonst existiert die Funktion nicht. 





** ~def~: Syntaxregel  (1) 



*** Syntax für ~def~ (Teil 1)				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Der Anweisung ~def~ folgt in der gleichen Zeile 
  - der zu definierende Funktionsname 
  - ein Klammerpaar ~()~
  - und ein Doppelpunkt ~:~ 
- Die Anweisungsfolge kommt in den folgenden Zeilen
  - *eingerückt* um vier Leerzeichen 

*** UEBUNG Eine Zeile für ~def~? 

In vorheriger Übung gelernt: IN klammern darf Zeielumbruch schadlos
erfolgen. Was sagt uns das für die Definition von Funktionen? 

Probieren Sie das in einem Notebook aus! 



** Namenskonvention für Funktionsnamen 

- Syntaxregel für Funktionsname: Wie für Variablennamen 
- Konvention: Wie für Variablennamen
  - Kleinbuchstaben am Anfang
  - Mehrere Worte durch ~_~ verbunden 


** Schlüsselwort: ~def~						   :subslide:

- ~def~ hat offenbar Sonderrolle 
- Als normaler Name benutzbar? 
- *Nein!* 
  - Ein weiteres Schlüsselwort!


** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 


** Einrückung? 

- Durch die Einrückung sind die Anweisungen bestimmt, die mit dem
  Funktionsnamen verbunden werden
- Ende der Einrückung: Ende der Funktionsdefinition 
- Darauf folgt: Einrückungen wichtig für Struktur
  - Python: Willkürliches Ein-/Ausrücken fehlerhaft! 


** Visuelle Struktur 

- Python-Programme sind durch Einrückungen strukturiert 
- Wir brauchen keine zusätzlichen Strukturelemente
  - Wie beispielsweise Klammern ~{~ oder ~}~ 

- Kompakte, leicht zu lesende Ausdrucksweise! 


** Einrückung: Beispiel 

#+BEGIN_SRC python
%%tutor -t
def f():
    x = 5
    y = 17
    # weitere Anweisungen

# Definition von f zu Ende!

def g():
    a = 1
    b = a+1
    # usw

# Definition von g zu Ende!
z = 42
#+END_SRC

*** Wieviele Anweisungen hier ausgeführt?		    :animate:nolatex:


#+BEGIN_SRC python :exports code
pingo_title = "Wieviele Anweisungen hier ausgeführt?" 
pingo_type = "single"
pingo_questions = ["1", "2", "3", "7"]
pingo_duration = "30"

%pingo
#+END_SRC 


*** UEBUNG Leerzeichen? Tabs? 

Was sagt PEP8 dazu? 

Klar machen: das macht ein Editor sowieso 


** Visualisierung: Was passiert? 

- Beim Ablauf des obigen Beispiels: *drei* Anweisungen ausgeführt!
  1. Die Definition von ~f~ und Herstellung der Referenz auf
     Anweisungen
  2. Entsprechend: die Definition von ~g~
  3. Die Zuweisung ~z = 42~ 
- Zustand des Programms: Namen ~f~, ~g~ und ~z~ referenzieren Werte 

*** Zustand nach Funktionsdefinition				  :dropslide:

Abbildung [[fig:zustand-f-g-z]] stellt den Zustand nach der Definition von
~f~ und ~g~ dar. 

#+CAPTION: Zustand nach Definition von ~f~, ~g~ und Zuweisung an ~z~
#+ATTR_LaTeX: :width 0.75\linewidth :float nil
#+NAME: fig:zustand-f-g-z
[[./figures/frame-f-g-z.png]]


** Starke Analogie: Variablename, Funktionsname 

- Die Analogie zwischen Zuweisung und Funktionsdefinition ist sehr eng! 

- Funktionsnamen benehmen sich nahezu identisch zu Variablennamen 

- Aber Notation doch recht unterschiedlich? 

*** Unterschiedliche Notation für Variablen und Funktionen?	  :dropslide:

Das hat letztlich pragmatische und auch Geschmacksgründe. Tatsächlich
gibt es Programmiersprache (etwas Lisp), bei denen diese Analogie noch
viel enger ist und auch in der Syntax kaum ein Unterschied in der
Definition einer Variablen  oder eines Funktionsnamens liegt. 

** Sprechweise: Objekt 

- Wir haben Namen für Werte, für Folgen von Anweisungen, usw.  
- Das wird unübersichtlich!

*** Verallgemeinerung: Objekt					    :animate:

- Verallgemeinern wir die Sprechweise: Objekte
  - Wenn es auf die Unterscheidung nicht ankommt
  - Werte sind Objekte
  - Folgen von Anweisungen sind Objekte
  - ... 
- Wir haben: Namen für /*Objekte*/ 


** ~def~ definiert ein Objekt 

- Damit Analogie zwischen ~=~ und ~def~ noch enger
  - Eine Zuweisung ~=~ erzeugt ein Objekt und bindet den Namen daran
    - Das Objekt ist hier der Wert 
  - Eine Funktionsdefinition erzeugt ein Objekt und bindet den Namen
    daran
    - Das Objekt ist hier die Folge von Anweisungen 

- Funktionen (=Folge der Anweisungen) benehmen sich nur wenig anders
  als normale Werte! 


* Aufruf 

** Aufruf einer Funktion 

- Funktionsfolgen mit Namen versehen: Toll!
- Aber wie Nutzen? 
- Genauer: Wie dafür sorgen, dass die Anweisungen einer Funktion an
  einer Stelle im Programm ausgeführt werden?
  - Ein /Funktionsaufruf/ durchführen 

** Aufruf einer Funktion: Syntax 

- Einfache Syntax: Den Funktionsnamen und ein Klammerpaar hinschreiben
- Als Teil eines Ausdrucks 
- Beispiel: 

#+BEGIN_SRC python
%%tutor -t 
def f():
    x = 42
    y = 17

# hier wird aufgerufen
z = "vorher"
f()
z = "nachher"
#+END_SRC


** Aufruf einer Funktion: Semantik  

Wir erweitern das Ausführungsmodell:

*** Aufruf einer Funktion: Semantik (v1) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
  - Vorstellung: Der Aufruf der Funktion wird durch die Anweisungen
    der Funktion ersetzt und wird dann ausgeführt 
- Nach Ausführung der letzten Anweisung der Funktion: Mit der
  Anweisung nach dem Aufruf weitermachen 

** Aufruf einer Funktion: Semantik  

*** Das ist nur eine erste Vorstellung			       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Die Definition hier ist unvollständig und nicht ganz korrekt. Wir
brauchen dazu noch ein paar Erweiterungen! 



*** UEBUNG WArum sit das nur eine grobe Entsprechung

Wo sind die Unterschied? Zumindest einer klar: Im Zustand fehlt der
Eintrag für den Funktionsnamen f . Und die Variablen x und y sind
nicht im Scope. 

** Variablen: Lebensdauer 

- Was passiert mit ~x~ und ~y~ aus der Funktion?
- Verschwinden nach Rückkehr aus der Funktion! 

*** Lebensdauer? 						    :animate:

- Variable, an die innerhalb einer Funktion zugewiesen
  wird, ist *lokal* zu dieser Funktion
  - Existiert nur, solange Anweisungen dieser Funktion ausgeführt
    werden
  - Verschwindet nach Ende der Funktion
    - (bis auf Ausnahmen, siehe später) 


** Namensraum (Namespace) 



*** Namensraum (Namespace) 				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Ein /Namensraum/ (oder /namespace/) ist eine Abbildung von Namen zu
Werten.  Namensräume gruppieren Namen, z.B. Variablennamen. 

Namen in unterschiedlichen Namensräumen sind von einander isoliert;
der gleiche Name kann in unterschiedlichen Namensräumen verwendet
werden und auf unterschiedliche Objekte verweisen. 

** Namensraum (Namespace) 

*** Namespaces							  :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:

- Ein Funktionsaufruf erzeugt einen Namensraum für
  diese Funktion. Dieser Namensraum verschwindet wenn die Funktion
  zurückkehrt. 
- Alle vordefinierten Funktionen existieren in einem eignen Namensraum
  (mit Namen ~builtins~). 
- Alle globalen Namen existieren in einem eigenen Namensraum.
- Namensräume können sich während der Laufzeit verändern (und tun das
  typischerweise auch). 
- Siehe [[https://docs.python.org/3/tutorial/classes.html][Abschnitt 9.2]] für Details. 

** Scope 


***  Scope 					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Der /Scope/ eines Namensraums sind die Zeilen des Programms, in denen
auf dessen Namen /direkt/ zugegriffen werden kann. Der Scope bestimmt
die Sichtbarkeit eines Namens.

Ein Scope ist eine statische Eigenschaft des
Programms; er entsteht /nicht/ zur Laufzeit. 

Ein Name kann an einer Stelle des Programms nicht sichtbar sein, aber
durchaus zur Laufzeit existieren. Er heißt dann /out of scope/.

Verkürzend sprechen wir auch von /Scope einer Variable/ und meinen damit den
Scope des Namensraum, zu dem der Name dieser Variable gehört. 

** Frame 

*** Frame						       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Der /Frame/ einer Funktion beschreibt /zur Laufzeit/ ihren Zustand. Er
enthält u.a. 
- den Namensraum der Funktion
- Information, wo das Programm nach Ende der Funktion fortgesetzt
  wird. 




*** Anmerkung						   :B_note:dropslide:
    :PROPERTIES:
    :BEAMER_env: note
    :END:

Das stimmt nicht ganz. Wir werden diese Definition in folgenden
Kapiteln noch verfeinern. 

*** Anmerkung: Pythontutor				   :B_note:dropslide:
    :PROPERTIES:
    :BEAMER_env: note
    :END:

Pythontutor stellt den Ablauf eines Programms dar. Also werden dort
die /frames/ angezeigt. Die Namensräume sind als Teil des Frames
sichtbar, werden aber nicht besonders als solche markiert. 


** Scope/Frame: Beispiel 

#+BEGIN_SRC python
%%tutor -t
def f():
    x = 42
    y = 17

z = "vorher"
f()
z = "dazwischen"
f()
z = "danach" 
#+END_SRC


*** Unterschiedliche Namensräume 				  :dropslide:

Die folgenden Abbildungen zeigen die unterschiedlichen Namensräume bzw. Frames. In der
Pythontutor-Anzeige werden dabei auf der rechten Seite die Frames
separat angezeigt: 

- Ein /global frame/: Die Namen, die im aufrufenden Teil des Programms
  bekannt sind.
- Der frame für die Funktion ~f~: Namen, die nur innerhalb von ~f~
  bekannt sind und die danach wieder verschwinden. 


In den einzelnen Schritten geschieht folgendes: 

1. Nach Definition von ~f~, vor dem ersten Aufruf (Abbildung
   [[fig:pt-vor-f1]]): hier sind lediglich die Namen ~z~ und ~f~
   bekannt. Der Aufruf von ~f~ wird als nächstes ausgeführt.
#+CAPTION: Aufruf einer Funktion: Vor erstem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-vor-f1
[[./figures/pt-f-1-vorf.png]]
2. [@2] Innerhalb des ersten Aufrufs von ~f~ (Abbildung [[fig:pt-in-f1]]): Kurz vor
   Ende von ~f~ sind die beiden Namen ~x~ und ~y~ bekannt, die lokal
   innerhalb der Funktion eingeführt wurden. Achten Sie darauf, dass
   diese Namen in einem anderen Namensraum -- dem von ~f~ -- existieren.
#+CAPTION: Aufruf einer Funktion: Im ersten Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-in-f1
[[./figures/pt-f-2-inf1.png]]
3. [@3] Nach Abschluss des ersten Aufrufs von ~f~, vor dem zweiten
   (Abbildung [[fig:pt-zwischen-f]]): Achten Sie darauf, dass der
   Namensraum von
   ~f~ nicht mehr existiert und damit auch die beiden Namen ~x~ und
   ~y~ verschwunden sind (ebenso wie die Werte, die von ~x~ und ~y~
   referenziert wurden -- es gibt ja keinen Namen mehr, unter denen
   man sie finden könnte). Es existieren jetzt lediglich die schon
   vor dem Aufruf bekannten Namen ~z~ und ~f~. ~z~ referenziert
   inzwischen einen anderen Wert, nämlich die Zeichenkette
   /dazwischen/.
#+CAPTION: Aufruf einer Funktion: Nach erstem Aufruf, vor zweitem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-zwischen-f
[[./figures/pt-f-3-dazwischen.png]]
4. [@4] Wir sind im zweiten Aufruf von ~f~ (Abbildung [[fig:pt-inf2]]). Das
   erkennen Sie in diesem Beispiel an dem Wert von ~z~ im globalen
   Namensraum; aus den Pfeilen für die auszuführende Instruktion ist das
   nicht ersichtlich -- die zeigen ja lediglich auf die aktuelle
   Stelle. Die (neu geschaffenen) Namen ~x~ und ~y~ regenerieren die
   gleichen Werte wie oben (die ebenfalls neu geschaffen wurden).
#+CAPTION: Aufruf einer Funktion: Im zweiten Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-inf2
[[./figures/pt-f-4-inf2.png]]
5. [@5] Nach dem der zweite Aufruf von ~f~ abgeschlossen wurde (Abbildung
   [[fig:pt-nach-f]]) sind wieder die beiden Namen (samt referenzierter
   Werte) ~x~ und ~y~ verschwunden. Der Name ~z~ zeigt auf den neuen
   Wert. 
#+CAPTION: Aufruf einer Funktion: Nach zweitem Aufruf
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-nach-f
[[./figures/pt-f-5-danach.png]]



** Funktionen haben keinen Effekt? 

- Wenn die Variablen der Funktion nach Ende der Funktion vernichtet
  werden -- dann hat eine Funktionsausführung doch gar keinen Effekt?
  - Oder: Verändert den Zustand nicht?

#+CAPTION: Funktionen ohne Effekt?
#+ATTR_LaTeX: :width 0.25\linewidth
#+NAME: fig:calvin-facepalm
[[./figures/facepalm.png]]


** Funktionen ohne Effekt: Beispiel 

Was ist der Wert von ~x~ am Ende? 

#+BEGIN_SRC python
%%tutor
def f():
    x = 42

# rufe f auf:    
f()
# greife auf x zu:
x
#+END_SRC


* Rückgabewert 
** Rückgabewert 
- Benötigt: Mechanismus, um Wert aus Funktion an den aufrufenden
  Programmteil zu transportieren
  - Geht nicht in normaler Variable 


** Neue Anweisung: ~return~

*** ~return~-Anweisung					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:
- Die Anweisung ~return~ erlaubt, einen beliebigen Wert aus einem 
  Funktionsaufruf an den aufrufenden Teil zu transportieren
  - Auf ~return~ darf ein beliebiger Ausdruck folgen
  - Des Wert wird /zurückgegeben/
- ~return~ ist ein Schlüsselwort 

*** Beobachtung							    :animate:

- Ausführungsmodell erweitert! 


** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 
- ~return~ 


** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v2) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
  - Vorstellung: Der Aufruf der Funktion wird durch die Anweisungen
    der Funktion ersetzt, und dann wird ausgeführt
- Bei der Ausführung einer Funktion wird ein neuer Namensraum für die
  Variablen der Funktion angelegt
  - Dieser Namensraum wird nach Ende der Funktion wieder vernichtet 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~ 

** Funktion mit ~return~: Beispiel 

#+BEGIN_SRC python
%%tutor -t
def pi():
    return 3.14159296

x = pi()
#+END_SRC


*** Erläuterung							  :dropslide:

Was geschieht bei der Ausführung dieses kleinen Programms? Betrachten
wir drei Schritte: 

1. Unmittelbar vor dem Aufruf der Funktion ~pi~ (Abbildung [[fig:pt-pi-vor]]) ist als
   einziger Name der Funktionsname ~pi~ bekannt. Die nächste
   auszuführende Anweisung ist der Aufruf.
#+CAPTION: Vor dem Aufruf der Funktion ~pi~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-vor
[[./figures/pt-pi-1.png]]
   
2. [@2] Nach dem Aufruf und nach der Ausführung der Anweisung ~return~
   (Abbildung [[fig:pt-pi-return-value]]) wird im Namensraum von ~pi~ eine
   /scheinbare/ Variable ~return value~ angelegt. Diese Variable zeigt
   auf den Wert des Ausdrucks, den ~return~ bearbeitet. Wie jeder
   andere Name im Namensraum einer Funktion wird auch dieser Name
   nach Rückkehr vernichtet. 
#+CAPTION: Nach Berechnung des Rückgabewerts, Anlegen der scheinbaren Variable ~return value~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-return-value
[[./figures/pt-pi-2.png]]

3. [@3] Aber der /*Wert*/ dieser scheinbaren Variable bleibt bei der
   Rückkehr aus der Funktion erhalten! Dieser Wert wird wie ein ganz
   normaler Wert weiterverwendet (es /ist/ ein ganz normaler
   Wert). Dieser Wert /ersetzt/ den Aufruf von ~pi~ in dem Ausdruck,
   in dem der Ausdruck vorkam. 

   Im Beispiel hier ist das die Zuweisung an die Variable ~x~. Als
   Effekt stellt sich ein: ~x~ wird zu einem Namen für den Wert, den
   die Funktion ~pi~ mit der Anweisung ~return~ angegeben hat. 

#+CAPTION: Nach Ersetzung des Funktionsaufrufs durch den Rückgabewert, Zuweisung an ~x~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-pi-danach
[[./figures/pt-pi-3.png]]


Anmerkung: Die tatsächliche technische Realisierung innerhalb eines
Python-Interpreters funktioniert so ähnlich, allerdings mit ein paar
Abweichungen im Detail. 

** Funktion ohne ~return~? 

Was passiert, wenn eine Funktion keine ~return~ Anweisung hat? 

#+BEGIN_SRC python
%%tutor
def no_return():
    x = 17
    y = 42*x

z = no_return()
#+END_SRC

*** Visualisierung						  :dropslide:

Auch wenn eine Funktion keine explizite ~return~-Anweisung enthält, so
wird doch stets ein Wert zurückgegeben. Allerdings braucht es hier
eine Vereinbarung, welcher Wert das sein soll (man könnte einen
zufälligen Wert nehmen, aber das würde auch zu zufälligen Programmen
führen). Eine gängige Festlegung ist hier (in Python wie in ähnlichen
Sprachen), den speziellen Wert ~None~ vorzusehen, der das Fehlen eines
eigentlich sinnvollen Wertes anzeigt. ~None~ ist keine Zahl, keine
Zeichenkette, kein ... sondern gehört zu einem eigenen Datentyp. 

#+BEGIN_LaTeX
Abbildung~\ref{fig:no-return} visualisiert das: Tatsächlich existiert der Rückgabewert \texttt{None} im Namensraum der Funktion \texttt{no\_return}. 
#+END_LaTeX


#+CAPTION: ~None~ als Rückgabewert bei Fehlen von ~return~
#+ATTR_LaTeX: :width 0.75\linewidth
#+ATTR_LaTeX: :caption \caption{~None~ als Rückgabewert bei Fehlen von ~return~ \label{fig:no-return}}
#+NAME: fig:no-return
[[./figures/pt-no-return.png]]




** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v3) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
- Bei der Ausführung einer Funktion wird ein neuer Namensraum für die
  Variablen der Funktion angelegt
  - Dieser Namensraum wird nach Ende der Funktion wieder vernichtet 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~
  - Fehlt ein expliziter Rückgabewert, so nimm ~None~ als besonderen
    Wert an

** Funktion mit leerem ~return~

Ein ~return~ ohne Ausdruck? 

#+BEGIN_SRC python
%%tutor
def empty_return():
    x = 17
    y = 42*x
    return 

z = empty_return()
#+END_SRC



** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
- ~and~, ~or~
- ~def~ 
- ~return~ 
- ~None~
  - ~None~ wird sich an vielen Stellen als praktisch erweisen, um das
    Fehlen eines eigentlich sinnvollen Wertes darzustellen
  - Achtung: ~None~, nicht ~none~! 


* Parameter 

  
** Funktionen bis jetzt: Langweilig

- Unsere Funktionen machen immer das gleiche 
- Nur nützlich, wenn wirklich /identischer/ Code mehrfach in einem
  Programm vorkäme
- Flexibler?
  - Funktion in Mathematik: Abbildungen von Werten auf Werte

- Parameter! 

** Funktion mit Parameter: Idee 

- Funktionen können ja Variablen benutzen
  - Sind innerhalb des Scopes der Funktion
  - Funktion weist Werte zu 
- Wie wäre es, wenn Variablen der Funktion /*von außen*/ mit Werten
  versorgt werden könnten?
  - Normale Variable im Scope der Funktion
  - Aber der Wert wird durch aufrufenden Programmteil festgelegt? 


** Funktion mit Parameter: Syntax der Definition 

- Wir machen Anleihe bei mathematischer Notation
- Zu belegende Variablennamen werden in Klammern nach Funktionsname
  angegeben
  - Der sog. /formale Parameter/ 
- Beispiel: 

#+BEGIN_SRC python
  # Eine Funktion f mit formalem Parameter a 
  def f(a):
      # In Funktion: a ist ganz normale Variable
      return a+1
#+END_SRC


** Funktion mit Parameter: Aufruf 

- Wie ruft man eine solche Funktion auf? 
  - Wie legt man den Wert für den formalen Parameter fest? 
- Einfach: bei Aufruf, in Klammern angeben
  - Der /übergebene Wert/, der /tatsächliche Wert/, das /Argument/,
    der /actual parameter/

#+BEGIN_SRC python
%%tutor
def f(a):
    return a+1

x = f(2)
#+END_SRC


** Funktion mit Parameter: Semantik des Aufrufs 

- Semantik: Formaler Parameter wird zu Namen für den übergebenen Wert 

*** Literal als Argument					  :dropslide:

In diesem ersten Beispiel übergeben wir einen festen Wert an eine
Funktion mit einem Parameter. Dazu wird zunächst dieser Wert -- im
Beispiel die Zahl 2 -- erzeugt. Der formale Parameter wird im Moment
des Aufrufs zur Referenz für diesen Wert.  (Wie sollte es auch anders
funktionieren, wenn man Variablen als Namen für Werte auffasst?)
Abbildung [[fig:pt-fa-wert]] illustriert das. 

#+CAPTION: Formaler Parameter ist Name für übergebenen Wert
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-wert
[[./figures/pt-fa.png]]


** Funktion mit Parameter: Aufruf mit Ausdruck 

- Vorheriges Beispiel: Fester Wert übergeben 
- Geht das auch mit Ausdruck?
  - Erwartung? Wert übergeben? 


#+BEGIN_SRC python
%%tutor
def f(a):
    return a+1

x = f(2+2)
#+END_SRC


*** Ausdruck als Argument					  :dropslide:

Wenn wir einen Ausdruck übergeben, so passiert ebenfalls das
Naheliegende: Der Wert des Ausdrucks wird bestimmt und erzeugt. Dann
wird der formale Parameter zum Namen für diesen Wert. Siehe
Abbildung [[fig:pt-fa-ausdruck]]. 

#+CAPTION: Formaler Parameter ist Name für Wert eines übergebenen Ausrucks
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-ausdruck
[[./figures/pt-fa-ausdruck.png]]


** Funktion mit Parameter: Aufruf mit Variable

- Was, wenn Variable an Funktion übergeben wird? 
- Wie bisher! Formaler Parameter ist Name des /Wertes/


#+BEGIN_SRC python
%%tutor
def f(a):
    return a+1

y = 5
x = f(y)
#+END_SRC


*** Variable als Argument					  :dropslide:


Auch wenn eine Variable an eine Funktion übergeben wird, passiert
wieder genau das gleiche: der formale Parameter wird zu einem (hier:
weiteren) Namen für den übergebenen Wert. Abbildung [[fig:pt-fa-y]] zeigt
deutlich: ~a~ und ~y~ sind beides Referenzen auf den gleichen Wert. 

#+CAPTION: Formaler Parameter ist Name für Wert einer Variablen 
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa-y
[[./figures/pt-fa-y.png]]

**** Formale Parameter werden NICHT zu Namen für Variablen     :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:

 Hier gilt ähnliches wie bei der Zuweisung: Der formale Parameter ist
 ein Name für den /Wert/. Ein formaler Parameter kann kein Name für
 einen anderen Namen sein. 


*** UEBUNG Und f(y+2) 

animieren lassen, erklären was passiert 


** Zuweisung an formale Parameter? 

- Was geschieht, wenn Funktion Wert an formalen Parameter zuweist?
  - Wert von ~y~ am Ende? 

#+BEGIN_SRC python
%%tutor -t
def f(a):
    a = a+1
    return a

y = 5
x = f(y)
#+END_SRC

*** Was immer geschieht!					    :animate:

- Die Variable ~a~ wird zu einem Namen für den neuen Wert 
- Warum sollte sich dadurch an der Variable im Aufruf  etwas ändern??


*** Zuweisung an formale Parameter -- Einzelschritte 		  :dropslide:


Im einzelnen geschieht hier genau die zu erwartende Folge von
Einzelschritten. Beim Aufruf wird ~a~ zunächst zu einem (zweiten)
Namen für den Wert 5 (Abbildung [[fig:pt-fa2-vor]]). Nach der Zuweisung
wird ~a~ zu einem Namen für einen anderen Wert (Abbildung
[[fig:pt-fa2-nach]]). Dies beeinflusst nicht die Tatsache, dass ~y~ ein
Name für den Wert 5 ist.


#+CAPTION: Zuweisung an formalen Parameter in Funktion: Vor der Zuweisung
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa2-vor
[[./figures/pt-fa2-1.png]]

#+CAPTION: Zuweisung an formalen Parameter in Funktion: Nach der Zuweisung
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-fa2-nach
[[./figures/pt-fa2-2.png]]


*** UEBUNG Was passiert, wenn formaler Parameter und Argument gleichen Variabelennamen haben?  

Überlegen, Namensraum verstehen, animation ? 


** Aufruf: Gleicher Name mehrfach? 

Was passiert bei: 

#+BEGIN_SRC python :exports both :results output
  def f(x):
      return 2*x

  x = 17
  x = f(x)
#+END_SRC 

#+RESULTS:
: 34


*** Nichts unerwartetes!					    :animate:

Es gibt einfach zwei Namen ~x~. Die sind aber durch den jeweiligen
Namensraum eindeutig zuordenbar und haben nichts mit einander zu tun. 

*** Details							  :dropslide:

In diesem Beispiel ist es Zufall, dass beide ~x~ zunächst auf das
gleiche Objekt (die Zahl 17) verweisen (Abbildung
[[fig:pt-call-f-x-x]]). Der Name des formalen Parameters der Funktion
~f~ hat mit dem Namen des Arguments des Aufrufs von ~f~ nichts zu tun!

#+CAPTION: Aufruf von ~def f(x)~ mit Argument ~x~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-call-f-x-x
[[./figures/pt-call-f-x-x.png]]


In Abbildung haben wir ein ähnliches Beispiel: Beim Aufrufer existiert
ein Name ~x~, der aber mit dem Aufruf der Funktion nichts zu tun
hat. Entsprechend ist der Wert auch unbeeinflusst. Hier referenzieren
die Variable ~y~ des Aufrufers und das ~x~ der Funktion auf das
gleiche Objekt. 


#+CAPTION: Aufruf von ~def f(x)~ mit Argument ~y~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-call-f-x-y
[[./figures/pt-call-f-x-y.png]]











** Aufrufsemantik: Pass-by-assignment  

- Formal ist die Aufrufsemantik von Python ein
  sog. /Pass-by-assignment/ 
  - Den formale Parametern werden Werte der Argumente zugewiesen 

*** Unterschied zu anderen Sprachen			   :B_note:dropslide:
    :PROPERTIES:
    :BEAMER_env: note
    :END:

Wenn Sie mit anderen Sprachen (C oder C++) vertraut sind: Dies klingt
nach call-by-reference, ist aber nicht genau das gleiche. Wir kommen
darauf noch zurück. 



** Funktion mit mehreren Parametern: Syntax 

- Mehrere Variablen: Aufzählung, durch Komma getrennt
  - Ähnlich wie bei Zuweisung 
- Beispiel: 


#+BEGIN_SRC python
  def f(a, b, c):
      # In Funktion: a, b, c sind ganz normale Variablen
      return a+b*c

  # Aufruf:
  f(1, 2, 3)
#+END_SRC


** Funktion mit Parametern: Syntax allgemein  

Eine Funktion kann eine beliebige Anzahl an Parametern haben: 

#+BEGIN_SRC python 
  def f(arg1, arg2, ..., argN):
      # Folge von Anweisungen
      ... 
      ... 
      # Optional, aber oft sinnvoll:
      return Rueckgabewert
#+END_SRC


** Funktion mit mehreren Parametern: Semantik 

- Pass-by-assignment wird auf alle formalen Parameter separat
  angewandt
- Genauer:
  - Die /Werte/ aller Argumente werden bestimmt
  - Die formalen Parameter werden zu Namen für diese Werte 
  - Ganz analog zur Mehrfachzuweisung!

*** UEBUNG Auswertungsreihenfolge? Macht das einen Unterschied? Wann würde es Unterschied machen? 

** Aufruf einer Funktion: Semantik  

*** Aufruf einer Funktion: Semantik (v4) 		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Aufruf der Funktion: Programm mit den Anweisungen der Funktion
  fortsetzen
- Bei der Ausführung einer Funktion wird ein neuer Namensraum für die
  Variablen der Funktion angelegt
- Formale Parameter sind Variablen in diesem Namensraum; sie sind Namen für
  die Werte der beim Aufruf übergebenen Argumente 
- Ersetze in der aufrufenden Anweisung den Aufruf der Funktion
  durch ihren Rückgabewert
  - Rückgabewert ist der Ausdruck nach ~return~
  - Fehlt ein expliziter Rückgabewert, so nimm ~None~ als besonderen
    Wert an



* Seiteneffekt 

** Besondere Funktionen: Beispiel ~print~

Aufruf einer /vordefinierten/ Funktion: 

#+BEGIN_SRC python
print("Hallo GP1")
x = 42
print(x)
#+END_SRC

** ~print~: Seiteneffekt, Prozedur 

~print~ ist Beispiel für eine Funktion mit einem /Seiteneffekt/ 

*** Seiteneffekt 				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:


Ein /Seiteneffekt/ (Wirkung, side effect) ist eine Aktivität des
Programms, die 
- /außerhalb/ des Programms (oder Programmteils) eine Wirkung hat
- aber den /Zustand/ des Programms (Programmteils) /nicht/ verändert. 


*** Prozedur						       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Funktionen mit Seiteneffekten werden auch /Prozeduren/ genannt. Der
Begriff wird insbesondere verwendet, wenn  Funktionen keinen
Rückgabewert haben. 

** Funktion oder Prozedur? 

Sind das Funktionen oder Prozeduren: 
- Summe zweier Zahlen berechnen?
- Festellen, ob eine Zahl ungerade ist?
- Eine Tabelle der Klausurergebnisse ausgeben? 

** Seiteneffekt von ~print~ 

Bei ~print~: 
- Gib den Wert des Arguments aus
- Wohin? Auf die /Standard-Ausgabe/
  - Bei Jupyter: Wird unterhalb der Zelle angezeigt
  - Allgemein: Je nach Ausführungskontext  (Terminal, ...) 


*** Seiteneffekt und funktionale Sprachen 			  :dropslide:

Mit dieser Definition läßt sich eine funktionale Programmiersprache
einfach charakterisieren: Eine Sprache, in der es keine Seiteneffekte
gibt. 

Mehr dazu in der Vorlesung Grundlagen der Programmiersprachen. 


*** UEBUNG print bei strings mit escape sequenzen 

Unterschied klarmachen und ausprobieren: 

#+BEGIN_SRC python
s1 = "c:\documents\bla.txt"
print(s1)
s1
#+END_SRC

bzw. 

#+BEGIN_SRC python
s1 = r"c:\documents\bla.txt"
print(s1)
s1
#+END_SRC


*** UEBUNG print von triple-quotes 

Ähnlich wie davor; aber jetzt triple quoted strings. Wie ist das mit
Einrückung? 


** Weitere Aspekte von ~print~: Mehrere Parameter 

- ~print~ kann eine /beliebige Anzahl/ an Parametern verarbeiten
  - Durch Komma
  - Werden nach einander ausgegeben 
  - (Das geht bei allen Funktionen, siehe späteres Kapitel) 
- Beispiel: 

#+BEGIN_SRC python :exports both :results output
print("Hallo", "GP", 1)
#+END_SRC 

#+RESULTS:
: Hallo GP 1


** Weitere Aspekte von ~print~: Benannter Parameter 

- Beim /Aufruf/ kann an ~print~ ein Parameter mit einem Namen versehen
  werden
  - (Das geht bei allen Funktionen, siehe späteres Kapitel) 

*** Beispiel: ~end~						    :animate:

- Parameter von ~print~: ~end~
  - Gibt Zeichen an, mit dem ~print~ die Ausgabe abschliesst
  - Wird Parameter nicht angegeben, so macht ~print~ einen
    Zeilenumbruch
- Brauchen wir für Beispiele in folgenden Kapiteln 


** Weitere Aspekte von ~print~: Benannter Parameter ~end~

Vergleiche die beiden Code-Blöcke: 


*** Version 1 

#+BEGIN_SRC python :exports both :results output
print("Hallo")
print("GP1")
#+END_SRC 

#+RESULTS:
: Hallo
: GP1

*** Version 2 


#+BEGIN_SRC python :exports both :results output
print("Hallo", end=" ")
print("GP1")
#+END_SRC 

#+RESULTS:
: Hallo GP1




** Weiteres Beispiel für Funktionen 

Was wird hier ausgegeben? 

#+BEGIN_SRC python :exports code :results output
  def m(x):
      x += 1
      return x*x

  i = 2
  i = m(i) + i
  print(i)
  i = 2
  i = m(m(i)) + m(i) + i
  print(i)
#+END_SRC 

#+RESULTS:
: 11
: 111


***  Pingo							    :nolatex:


#+BEGIN_SRC python :exports code
pingo_title = "Resultat?" 
pingo_type = "single"
pingo_questions = ["1 und 11", "0 und 100", "10 und 1000", "111 und 1111", "11 und 111"]
pingo_duration = "120"

%pingo
#+END_SRC 



* Randbemerkungen, Zusammenfassung  

** Funktionen finden 

Wo gibt es Funktionen? 

- Selbst geschrieben 
- Eingebaut, z.B. ~print~
  - Siehe [[https://docs.python.org/3/library/functions.html][Liste der eingebauten Funktionen]]
- In ~Modulen~, zusammengestellt zu ~Bibliotheken~ -- siehe später 

** Eingebaute Funktionen, weitere Beispiele 

*** ~type~

#+BEGIN_SRC python
  type(42)
  type(0.01)
  type("Hallo GP1")
#+END_SRC


*** ~max~ 

#+BEGIN_SRC python
max(1, 2, 3)
#+END_SRC


*** UEBUNG Beispiele fuer Ubeungen 

- chr()
- abs()
- complex()
- divmod()
- float() float("17.2")
- help()
- max(), min()
- len() für string
  - wie ist das mit unicode strings? Was gibt len hier aus? 



** Funktionen und Stil: Namenskonvention 

Wie schreibt man Funktionen stilsicher?  (PEP8)

- Namen: Kleinbuchstaben oder Unterstrich ~_~
  - Beispiel: ~dies_ist_ein_langer_funktionsname~
  - Kein CamelCase
- Leerzeichen:
  - Keine Leerzeichen zwischen ~funktionsname~ und ~(~
    - Nicht bei Definition, nicht bei Aufruf
  - Keine nach öffnender Klammer 
  - Nach Komma (wie üblich) 


** Kommentare 

*Konvention*: Jede Funktion mit einem ~docstring~ versehen
- ~docstring~ : Die erste Anweisung in einer Funktion ist eine Zeichenkette
- Erläutert Zweck und Nutzung der Funktion 
- Details: [[https://www.python.org/dev/peps/pep-0257/][PEP 257]]

Konvention verletzt?  
- Programmierwerkzeuge versagen 
- Beispiel: [[http://docutils.sourceforge.net][docutils]]


** ~docstring~ 

- Kurzversion, eine Zeile
  - Befehlsform, beschreibe den Effekt der Funktion
  - Nicht die Parameter der Funktion wiederholen; das ist
    offensichtlich 
  - """Kommentiere Deine Funktionen ordentlich."""
- Langversion, mehrere Zeilen
  - Anfang wie bei einer Zeile
  - Dann Parameter aufzählen und /Zweck/ beschreiben
  - Ggf. Rückgabewert 


** Nützliche Kommentare 

#+CAPTION: Nützliche Kommentare retten Zeit
#+ATTR_LaTeX: :width 0.5\linewidth
#+NAME: fig:get_serial_number
[[./figures/get_serial_number.png]]


** ~docstring~: Beispiel 

#+BEGIN_SRC python

def complex(real, imag):
    """Form a complex number.

    Keyword arguments:
    real -- the real part
    imag -- the imaginary part
    """

    # Und hier würden Anweisungen folgen 
#+END_SRC


*** UEBUNG Beispoiele für docstrings schreiben lassen 

Funktionen vorgeben... 


** Kommentare sind Kommunikation 

#+CAPTION: Kommentare sind Kommunikation, möglicherweise mit sich selbst 
#+ATTR_LaTeX: :width 0.25\linewidth :float nil
#+NAME: fig:comments-communication
[[./figures/future_self.png]]



** Zusammenfassung 

- Die gleichen Anweisungsfolgen wiederholen sich oft in Programmen
- Zur einfachen Wiederverwendungen führen wir Funktionen ein
  - Werden von einem oder mehreren Teilen des Programms /aufgerufen/
- Interagieren mit aufrufendem Teil durch
  - /formale Parameter/, die beim Aufruf mit  /Argumenten/ versehen
    werden
  - /Rückgabewert/, der die Stelle des Funktionsaufrufs einnimmt
- Formale Parameter werden zu Namen für die Werte der Argumente
- Manchmal: /Seiteneffekte/ 
- Objekt: Verallgemeinert Sprechweise

** Wiederverwendung -- Die hohe Schule 

#+CAPTION: Die hohe Schule der Wiederverwendung
#+ATTR_LaTeX: :width 0.5\linewidth
#+NAME: fig:wally-reuse
[[./figures/dilbert-reuse.png]]



* IM zweiten Teil						   :noexport:


- Rücksprungadresse? oder schon hier? 
- geschachtelte Funktionsdefinition 
- Module
- Scopes
- Funktionsdefinition in if statements 
- lambda 
- yield 
