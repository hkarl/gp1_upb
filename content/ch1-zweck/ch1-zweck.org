#+TITLE: Kapitel 1: Zweck der Vorlesung Programmierung 
#+INCLUDE: "../template/header.org" :minlevel 2

#+STARTUP: showeverything
# TODO states: looks like this has to go on main file and cannot be
# included 
#+TODO: TODO(t) | UEBUNG(u) DONE(d)
#+OPTIONS: tasks:todo

#+LATEX_HEADER: \setcounter{chapter}{1}


* Überblick 
** Dieses Kapitel 
 
- Übersicht: Was beinhaltet /Programmieren/?
- Was macht eine gute Programmiererin aus? 
- Was soll in dieser VL erreicht werden? 
- Warum machen wir das so? 

** Setup 						  :skipslide:nolatex:
   
Main point here is to set up warnings properly for presentation and to
load tutormagic, so that we can later on use pythontutor for code
animations. 
   
#+BEGIN_SRC  python 
%load_ext tutormagic
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning, module='.*/IPython/.*')

import requests
import webbrowser
from IPython.core.magic import register_line_magic


pingo_host = "https://pingo.coactum.de/"
pingo_token = "BRx9QJP7rjdUGBq3x4hP"
pingo_session = "538312"


# Test-Session: 
pingo_url = pingo_host + "events/" + pingo_session + "/quick_start.json"
# Produktiv-Session: 
# pingo_url = "https://pingo.upb.de/events/204051/quick_start.json"

pingo_duration = '60'
pingo_type = "single"

@register_line_magic
def pingo(line):
    params = {'survey_name': pingo_title, 
              'predef_options': pingo_questions, 
              'q_type': pingo_type,
              'duration': pingo_duration, 
              'auth_token': pingo_token}

    r = requests.post(pingo_url, json=params)


    # session id not found
    if r.status_code == 404: 
        print ("404 error: session id not found")

    # wrong auth token
    elif r.status_code == 401:
        print (r.content)

    # e.g. not access to this session
    elif r.status_code == 200:
        print (r.content)

    # ok
    elif r.status_code == 201:
        webbrowser.open_new_tab(pingo_host + r.headers['Location'])

    # e.g. wrong parameters
    elif r.status_code == 500:
        print ("500 error: e.g. wrong parameters")

    # some other problem
    else:
        print (r.status_code)
#+END_SRC






* Programmierung 

** Was ist Programmierung? 

Freitext-Pingo! Bitte nur ein Schlagwort eingeben! 

#+BEGIN_SRC python :exports code
pingo_title = "Ein Schlagwort: Was ist Programmierung?" 
pingo_duration = "120"
pingo_type = "text"

%pingo
#+END_SRC 


**  Was ist Programmierung? 

#+CAPTION: Was ist Programmierung? 
#+ATTR_LaTeX: :width 0.5\linewidth
#+NAME: fig:programmierung
[[./uml/programmieren.png]]


  
** COMMENT Was ist Programmierung? 
- Denken in Algorithmen und Datenstrukturen 
- Entwickeln von Ideen zur Lösung eines Problems
- Ausdrücken in einen Formalismus
  - /Codierung/
- Nutzung von Werkzeugen 
- Finden und Nutzen von Teillösungen 



** Vorlesungsinhalt Programmierung 

Von allem ein bisschen, insbesondere: 

- Grundlegende Programmierparadigmen
  - Imperativ
  - Objektorientiert 
  - (Dynamisch vs. statisch typisiert)
- Coding
  - Entwicklung
  - Wiederbenutzung 
  - Test
  - Werkzeuge 



*** Programmierparadigmen					      :notes:

Mit dem Begriff /Programmierparadigmen/ klassifiziert man
Programmiersprachen in Familien. Innerhalb einer Familie kommen
ähnliche Konzepte und Grundannahmen zur Geltung. Das betrifft zum
Beispiel Annahmen über das Ausführungsmodell, über die Reihenfolgen
von Ausführungen, und ähnliches. Andere Aspekte sind die Organisation
des Codes in kleinere oder größere Einheiten. Stilfragen zählen
ebenfalls dazu.  



** VL Programmieren im Modulhandbuch 


*** Laut Modulhandbuch					    :B_zitat:
    :PROPERTIES:
    :BEAMER_env: zitat
    :END:

- Faktenwissen, unter anderem
  - die wesentlichen Konstrukte einer Programmiersprache (derzeit: 
    Python, in geringem Umfang auch Java), 
  - die Grundkonzepte von Komposition und Abstraktion in der Programmierung zu verstehen
- methodisches Wissen
  - die gelernten Sprachkonstrukte sinnvoll und mit Verständnis anzuwenden,
  - Software zu testen sowie Fehlerursachen zu finden und zu beseitigen,
  - objektorientierte Grundkonzepte zu verstehen und anzuwenden,
  - Software aus objektorientierten Bibliotheken wiederzuverwenden
- Transferkompetenz
  - praktische Erfahrungen in der Programmentwicklung auf neue Aufgaben zu übertragen
- normativ-bewertenden Kompetenzen
  - den Aufwand und die Durchführbarkeit von Programmieraufgaben zu beurteilen


** VL Programmiersprachen 

- Partnervorlesung (letztes Drittel dieses Semesters)

*** Laut Modulhandbuch                                              :B_quote:
    :PROPERTIES:
    :BEAMER_env: quote
    :END:

 Die Studierenden können Grundkonzepte von Programmier- und
 Anwendungssprachen erläutern. Sie können typische Eigenschaften
 nicht-imperativer Sprachen erklären. Sie sind in der Lage, einfache
 Grammatiken, Typenspezifikationen und funktionale Programme zu
 entwickeln. Sie sind in der Lage, praktische Erfahrungen in der
 Programmentwicklung auf neue Aufgaben zu übertragen. Sie besitzen die
 Fähigkeit, neue Programmier- und Anwendungssprachen selbstständig zu
 erlernen. 

** Programmieren? 

- Irgendwie dem Computer erklären was er machen soll?
- Irgendwie zusammen hacken...?

*** Wirklich? 							    :animate:

#+CAPTION: One does not simply walk into programming 
#+ATTR_LaTeX: :width 0.25\linewidth 
#+NAME: fig:walk-programming
[[./figures/simply-walk-programming.jpg]]


* Denken in Algorithmen und Datenstrukturen  

** Grobe Vorstellung

- Algorithmus: Was wird wie verarbeitet? 
- Datenstruktur: Wie werden Daten repräsentiert? 

** Algorithmus

*** Algorithmus 					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Ein *Algorithmus* ist eine endliche, eindeutige, unmissverständliche
Handlungsvorschrift zur Lösung eines Problems. 

** Algorithmus 


*** Historisch
- Erste Ideen, Abu Dscha'far Muhammad ibn Musa al-Chwarizmi, ca. 825 n.u.Z.
- Ada Lovelace, 1843, Berechnung von Bernoullizahlen 

*** Wie?							  

- Wie stellen wir das sicher? 
- Natürliche Sprache? 



** Datenstruktur 

- Welche Daten verwendet? 
- Wie repräsentiert?
- Wie manipulierbar? 

Formalisiert: 
- Abstrakter Datentyp 
- Siehe VL Modellierung 

** Datenstruktur 

*** Datenstrukur					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:


Eine *Datenstruktur* legt fest, 
- wie Daten in einem Rechner repräsentiert werden 
- und wie sie verarbeitet oder manipuliert werden können. 



** Algorithmus/Datenstrukturen in Isolation? 

Kann man sich das beliebig ausdenken? 

*** Nein!							    :animate:

- Hängt entscheidend vom *Maschinenmodell* ab 

Beispiele: 
- Normaler Rechner 
- Abstrakt: Turing-Maschine 
  - Siehe VL Modellierung, VL EBKfS 
- Quantencomputer 

** Maschinenmodell für diese VL? 

Wir gehen von /normalen/ Rechnern aus: 

- Speicher 
- Verarbeitung 
- Programm 


** Speicher							   :subslide:

- Enthält Daten
  - Unterteilt in kleinere Einheiten, /Speicherstellen/
  - Eine Speicherstelle kann nur endliche viele Werte unterscheiden (0
    oder 1, 0 bis 255, o.ä.) 
  - Einfachster Fall: Speicherstellen durchnummeriert 
- Inhalte der Speicherstellen zu einem Zeitpunkt: /Zustand/
  - *Zentraler Begriff*! 

*** Zustand					       :B_definition:animate:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Der *Zustand* eines Rechners ist ein Element einer diskreten Menge. Er
wird bestimmt durch den Inhalt aller (veränderlichen)
Speicherstellen des Rechners. 

** Verarbeitungseinheit						   :subslide:

- /Central Processing Unit/ (CPU) 
- Manipuliert Daten im Speicher
  - Manipuliert /Zustand/, /überführt/ Zustand in Folgezustand  
- Hält sich dabei an /Anweisungen/
- Es gibt nur endlich viele, wenige Anweisungen
  - Der /Instruktionssatz/

** Anweisung 

- Eine /Anweisung/ legt
  - für einen  /gegebenen/ Zustand fest,
  - welcher /folgende/ Zustand entsteht
- Vorstellung von /vorher, nachher/: /Ausführung/ einer Anweisung 

** Beispiele für Anweisungen 

- Tue nichts 
- Übertrage Daten von beliebiger Stelle des  Speichers in CPU
  - CPU: Teil des Zustands! 
- Übertrage Daten von CPU in beliebige Stelle des  Speichers 
- Lege in einer Speicherstelle die Summe des Inhalts zweier anderer
  Speicherstelle ab 
- Vergleiche zwei Daten und lege Vergleichsresultate als Teil des
  Zustands ab  


** Programm                                

- Eine /endliche/, /bekannte/, /lineare/ Folge von Anweisungen:  das /Programm/
  - Linear: Anweisungen sind durchnummeriert
  - Einfache Vorstellung: Zeilenweise, eine Anweisung pro Zeile 
- Anweisungen entstammen Instruktionssatz 

** Ausführungsmodell 

Mit Speicher, CPU, Instruktionssatz ergibt sich ein einfaches
/Ausführungsmodell/:

- CPU bearbeitet, zu jedem Zeitpunkt, eine /aktuelle Anweisung/ aus
  dem Programm
- Bearbeitung dieser Anweisung führt ggf. zur Veränderung der Daten
- Dann wird nächste Anweisung ausgeführt 




** Ausführungsmodell 

*** Ausführungsmodell					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Ein *Ausführungsmodell* legt fest, wie aus einem gegebenen Zustand der
Folgezustand entsteht. Für jede Anweisung aus dem Instruktionssatz.  



** Ausführung						      :skip:subslide:

- Ausführung beginnt mit einem Zustand 
- Jede Anweisung überführt einen Zustand in seinen /Folgezustand/
- Ausführung insgesamt also: /Folge von Zuständen/ 

** Ausführungsmodell 

#+CAPTION: Einfaches Ausführungsmodell
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:ausfuehrung
[[./uml/ausfuehrung.png]]


** Langweiliges Ausführungsmodell                                  :subslide:

*Immer* die nächste Anweisung? 

- Langweilig...

*** Flexibel?							    :animate:
- Die nächste auszuführende Anweisung kann von Vergleichen abhängen 
- Vorstellung eines /Sprungs/ in der Folge der Anweisungen 

** Welcher Zustand ändert sich bei Sprung?                         :subslide:

- Wichtiger Teil des Zustands:
  - Welche Anweisung wird gerade bearbeitet?
  - Welche Anweisung wird als nächstes bearbeitet?
- Normale Ausführung: Als nächstes wird die Anweisung in der folgenden
  Zeile bearbeitet
- *Sprung*: Als nächstes wird die Anweisung in einer anderen 
  Zeile bearbeitet


** Fertig? 

- Im Prinzip wären wir jetzt mit der Vorlesung fertig:
  - Instruktionssatz genau beschreiben
  - Details Ausführungsmodell genau beschreiben 
- Praktikabel? Nein!
  - Zu feingranular
  - Für Menschen schlecht verständliche Darstellung:
    Zustandsänderungen sehr kleinteilig
- Aber im Prinzip richtig! 

** Programmieren 

- Für ein gegebenes Problem ein Programm finden
- Also: eine Folge von Anweisungen, die das Problem /lösen/
  - Wie kommt man von beliebigem Zustand am Anfang (/Eingabe/) in
    einen gewünschten Zustand am Ende der Ausführung (/Ausgabe/)?  

** Programmieren - wie?  

- /Basteln/ bis es tut??
- Gutes Programmieren
  - *Systematisches* Nachdenken, Entwurf, Planung, Verständnis
  - Auch: Lesbarkeit, Nachvollziehbarkeit, Ästhetik 
- Systematik? -- Im Laufe der Vorlesung 

** Programmiersprachen 

- Heben das Abstraktionsniveau der Zustandsänderungen 
  - Mächtigere Anweisungen
  - Einfacher für Menschen
- Also: Definiere neuen Instruktionssatz, neue Vorstellung von
  Zustand, ... 
- Eine /Programmiersprache/ 


** Programmiersprache -- Definition			   :subslide:nolatex:



- Dient der Formulierung von
  - Algorithmen und
  - der in Algorithmen
    benutzen Datenstrukturen
- Definiert ggf. Begriff des /Zustandes/ und der Übergänge zwischen
  Zuständen
  - /Anweisungen/
  - Insgesamt: /Semantik/ der Sprache 
- Vorschriften, wie Anweisungen und Daten aufgeschrieben werden
  - /Syntax/ der Sprache 

** Programmiersprache -- Definition				  :dropslide:

*** Programmiersprache				     :B_definition:skipslide:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:



- Eine Programmiersprache dient der Definition von Algorithmen und der
  in Algorithmen benutzten Datenstrukturen.

- Sie definiert ggf. Begriff des /Zustandes/ und der Übergänge zwischen
  Zuständen. Hierfür wird meist der Begriff der /Anweisung/ verwendet.
  Dadurch wird die /Semantik/ der Sprache festgelegt.

- Zusätzlich legt eine Programmiersprache fest, wie Anweisungen und
  Datenstrukturen notiert werden. Dies bestimmt die  /Syntax/ der
  Sprache. 



*** Anmerkung: Zwei Sprachen 					      :notes:

Eigentlich besteht (nahezu) jede Programmiersprache aus zwei Teilsprachen: 
- Einer Sprache, die Daten beschreibt: wie sehen sie aus, wie sind sie
  benannt, welche Eigenschaften haben sie, wie können einfache Daten
  zu komplexeren Daten kombiniert werden?
- Einer Sprache, die Operationen auf Daten beschreibt: wie können
  Daten manipuliert werden, wie können neue Daten berechnet werden,
  unter welchen Bedingungen soll das geschehen? 

In Praxis sind diese beiden Teile einer Sprache oft nicht
unterscheidbar und eng mit einander verwoben. Es gibt aber durchaus
Beispiele, in denen nur ein Aspekt auftritt, etwa bei
Spezifikationssprachen für Typen. 


*** Anmerkung: Syntax und Semantik				      :notes:

Mit /Syntax/ werden die Regeln bezeichnet, die ein Text
einhalten muss, um in einer gegebenen Programmiersprache als gültig
angesehen zu werden -- man spricht dann von einem /syntaktisch
korrektem Programm/. Die VL Modellierung (und im weiteren
Studienverlauf die VL Formale Sprachen) stellt unterschiedliche
formale Techniken vor, solche Syntaxregeln zu formulieren.

Die /Semantik/ beschreibt, wie ein syntaktisch korrektes Programm
Eingaben auf Ausgaben abbildet. Insbesondere auch, wie die Semantik
eines Programms aus der Semantik von Teilen des Programms -- bis zu
einzelnen Anweisungen -- erklärt werden kann. Die mathematisch präzise
Definition einer Sprachsemantik ist dabei anspruchsvoll und wird in
dieser Vorlesung nicht weiter formal behandelt. Wir beschränken uns
hier auf intuitive Beschreibungen dieses Begriffs.


** Ausführung?							   :subslide:

- Aber: Solche Programme sind nicht mehr  direkt durch reale Maschinen ausführbar 

*** Das macht nichts!						    :animate:

- Wir stellen uns einfach eine irreale Maschine vor, die
  entsprechend fähig ist
- Später: von irrealer Maschine zu realer Maschine?!
  - /Interpreter/
  - /Compiler/ 


* Programmierparadigma

** Gute Programmiersprachen? 

- Was ist das richtige Abstraktionsniveau?
- Wie Sprachen gestalten, damit 
  - für Menschen einfach nutzbar?
  - für reale Maschinen gut umsetzbar? 

*** Grundlegende Ideen						    :animate:

- Ideen in /Programmierparadigmen/ beschreiben 
- Gruppieren Programmiersprachen zu Familien 

** Programmierparadigma 

Sprachen eines Paradigmas gleichen sich in Aspekten wie: 

- Was sind statische Aspekte eines Programms?
  - Konstanten? Daten? Typen? Code? Variablen? ...? 
- Was sind dynamische Aspekte eines Programms?
  - Variableninhalte? Variablen? Folge von Anweisungen?
  - Woher stammt Dynamik?
    - Eingaben? Zeitablauf? Ereignisse? Zufall? ...? 


** Programmierparadigmen: Beispiele 

#+BEGIN_LaTeX
Abbildung~\ref{fig:paradigmen-beispiele} zeigt Beispiele für Programmierparadigemn, die wir hier kurz betrachten. 
#+END_LaTeX


#+CAPTION: Beispiele für Programmierparadigmen
#+ATTR_LaTeX: :width 0.5\linewidth 
#+ATTR_LaTeX: :caption \caption{Beispiele für Programmierparadigmen \label{fig:paradigmen-beispiele}}
#+NAME: fig:paradigmen-beispiele
[[./uml/paradigmen.png]]




** Programmierparadigma: Imperativ				   :subslide:

- Älteste Sprachfamilie 
- Niedrige Abstraktionsebene
- Sehr nahe am realen Maschinenmodell
- Einfach zu erlernen, aber schlecht für große Anwendungen geeignet 

- Beispiele: BASIC, C, Pascal, ... 

** Programmierparadigma: Objektorientiert			   :subslide:

- Beobachtung bei imperativen Sprachen: Zusammenhang zwischen /Daten/
  und /Anweisungen/ oft schwer zu sehen
  - Insbesondere bei großen Programmen unübersichtlich
- Idee: Zusammenfassen!
  - Daten und der darauf anwendbare Code werden gemeinsam beschrieben 

- Beispiele: Smalltalk, C++, Java, Python 

** Programmierparadigma: Funktional				   :subslide:

- Vermeidung der Vorstellung eines /Zustands/
  - Keine Seiteneffekte
  - Programm ist eigentlich nur eine große Funktion 
- Programm selbst kann zum Gegenstand des Programms werden
  - Schlagwort: /Functions as first-class citizens/

- Beispiele: Lambda-Kalkül, Lisp, Haskell, F# 

** Programmierparadigma: Logisch				   :subslide:

- Ein Programm beschreibt Fakten und Schlussregeln
- /Maschine/ konstruiert durch Anwendung der Regeln auf Fakten neue
  Fakten 
- Wenn eine Frage als Fakt konstruiert werden kann, ist sie wahr 

- Beispiele: Prolog  

** Welches Paradigma für diese VL?

- Anforderungen
  - Leicht erlernbar
  - Praxisrelevant
  - Ausgangspunkt für weitere Ausbildung 

- Hier: 30% imperativ, 60% objektorientiert, 10% funktional

- Mehr Details, Beispiele: VL  Programmiersprachen 

** Paradigma und Sprache? 

- Meist keine 1:1 Beziehung
  - Kein Paradigma mit nur einer Beispielsprache
  - (Fast) keine Sprache folgt nur einem Paradigma exklusiv
- Meist Mischkonzepte, Überlappungen, ... 

* Welche Programmiersprache? 

** Anforderungen 

- Leicht erlernbar, gut strukturiert
- Praxisrelevant
- Deckt wesentliche Paradigmen ab 
- Ausgangspunkt für weitere Ausbildung
- Portierbar zwischen Betriebssystemen, Architekturen
- Spass! 


** Auswahl? 

- Keine Sprache erfüllt alle Anforderungen :-( 

- Kandidaten: C/C++, Java, Python 
  - Alle praxisrelevant, wesentlich im weiteren Studienverlauf 
- Oder Exoten: Javascript, Kotlin, Go, Rust, Scala, ...?  





** C/C++ ?							   :subslide:

- Nahe am Maschinenmodell
  - Es passiert nichts überraschendes (in C...)
- Wenig Abstraktion
- Wenig fehlerverzeihend
- Alte Sprache: viel historischer Ballast
  - Durch gewünschte /Rückwärtskompatibilität/
  - Insbesondere bei C++
- (Nahezu) keine funktionalen Aspekte  


*** Rückwärtskompatibilität					  :note:skip:

/Rückwärtskompatibilität/ ist eine Eigenschaft, die bei neuen
Versionen eines Systems -- hier: einer Programmiersprache --
auftritt. Rückwärtskompatibilität liegt vor, wenn die neue Version in
der Lage ist, Eingaben (hier: Programme) korrekt und unverändert zu
verarbeiten, die für die alte Version erstellt wurden. 

Beispiel: Benzinmotoren sind rückwärtskompatibel zu einander, da sie
alle Benzin verarbeiten. Mit der Einführung des Katalysators war dies
aber nicht der Fall, da verbleites Benzin nicht mehr verarbeitet
werden konnte. 

** Java?							   :subslide:

- Hohe Abstraktion
- Komplexes Ausführungsmodell
  - Viel /Magie/
- Moderne Sprache, die viele Trends integriert
  - Dadurch auch unübersichtlich
  - Beispiel: Funktional möglich, aber offensichtlich aufgepfropft 
- Hoher Einarbeitungsaufwand zu Beginn 


** Python?							   :subslide:

- Moderne Sprache, strikt verwaltet
- Weniger komplex als Java
- Sehr gut lesbar, kompakt
  - Typischerweise: 1/3 -- 1/5 vergleichbaren Java-Codes 
- Geringer Einarbeitungsaufwand
- Interpretiert, dadurch einfach zu experimentieren 
- Vor-/Nachteil: Keine statischen Typen 
- [[https://stackoverflow.blog/2017/09/06/incredible-growth-python/][Schnell wachsend]] , [[https://spectrum.ieee.org/computing/software/the-top-programming-languages-2019][IEEE Language Ranking ]]

** Vergleich: TIOBE Index 

- [[http://www.tiobe.com/tiobe_index][TIOBE Index]]: Welche Sprachen
  werden am Arbeitsmarkt nachgefragt?

Ranking: 
1. Java

2. C, C++

3. Python 


** Vergleich: TIOBE Index 

From [[https://www.tiobe.com/tiobe-index/][Tiobe Index 2018]]: 

#+CAPTION: TIOBE Index 2018
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:tiobe
[[./figures/tiobe-2018.png]]




** Ihre Erfahrung?						    :nolatex:

#+BEGIN_SRC python :exports code
pingo_title = "Mit welchen Programmiersprachen haben Sie Erfahrung? (Mehrfachnennung möglich)" 
pingo_type = "multi"
pingo_questions = ["Java", "C/C++", "Pascal", "Python", "Andere", "Gar keine"]
pingo_duration = "30"

%pingo
#+END_SRC 


** Konsequenz?						       :COMMENT:skip:

- Beginn:  Python -- ca. 3/4 der Vorlesung
  - Grundlegende imperative, objektorientierte, funktionale Aspekte 
- Zum Ende: Java -- ca. 1/4
  - Einführung statischer Typisierung 

(und C kommt im vierten Semester...) 

*** Vorteil?							    :animate:
- Einfacher Einstieg & breiter Horizont
- Zwei Sprachen sind kein Hexenwerk! 


** Konsequenz? 

- Hier:  Python als Einstieg 
  - Grundlegende imperative, objektorientierte, funktionale Aspekte
  - Plus *ein wenig* Java am Ende 
- In GPS, ggf. Eigeninitiative: Java 
  - Einführung statischer Typisierung
  - Wird für spätere Veranstaltungen gebraucht! 
- Im vierten Semester: C 

** Klausur? 

- Nur der Python-Teil ist klausurrelevant 
- Daher: Nur Übungsaufgaben für Python! 


** Alle Sprachen? 


#+CAPTION: Hartnäckigkeit kann sich auszahlen
#+ATTR_LaTeX: :float nil
#+NAME: fig:cobolsaurus
[[./figures/cobolsaurus.png]]




* Werkzeuge 

** Werkzeuge 

- Programmierer brauchen Werkzeuge, je nach Sprache 
- Wesentlich:
  - Editor
  - Debugger
  - Profiler
  - (IDE)
  - Dokumentation
  - Versionsverwaltung 

** Editor 

- Programmtext eintippen... 
- Einfacher Editor
  - Vertraut 
  - Aber *keine* spezifische Unterstützung für gewählte
    Programmiersprache
- Programmier-Editor
  - Unterstützt editieren in gewählter Sprache
  - Versteht Programmiersprache
  - Kann Vorschläge machen, Ergänzungen, ...


** Editor für diese VL?                                            :subslide:

- Prinzipiell: Nutzen Sie, was Sie wollen!
- Abgaben durch Browser-basiertes System
  - Jupyter,  [[http://jupyter.org][Projekt Webseiten]]
  - Insbesondere: Editor im Browser 


** Debugger

- Niemand programmiert fehlerfrei 
- Debugger hilft bei Fehlersuche
  - Programm gezielt anhalten
  - Variablenwerte anschauen, verändern
  - ... 

** Profiler 

- Laufzeit eines Programms untersuchen
- Wo ist es unnötig langsam?
- Statistiken für viele Läufe erheben 

** Dokumentation 

- Innerhalb eines Programms: Dokumentation, Kommentare
  - Notizen *was*, *warum* und *wie* geschieht
- In Programm verteilt
- Werkzeug: Dokumentation extrahieren und in kompakter Form bereit
  stellen  

- Beispiele: javadoc, doxygen (mit Abarten), pydoc, autodoc, ... 

** Versionsverwaltung 

- Kein Programm ist direkt perfekt
  - Verfeinert, Fehler behoben, ...
  - Es entstehen *Versionen* eines Programms 
- Handhabung?
  - Kopien in Ordnern? ~MyProgram/v17.3_after_midnight~ ?

** Werkzeuge für Versionsverwaltung				   :subslide:

- Nutzen Sie spezialisierte Werkzeuge!
- Nur eine Version des Programms in Bearbeitung
- Ältere Versionen, Alternativen zugreifbar

- Beispiele:
  - ~svn~, ~git~ (mit Zusatzfunktionen wie etwa ~github~ )
  - Jupyter: einfaches Abspeichern und Wiederbenutzen älterer
    Versionen (sog. /checkpoint/)

*** Versionsverwaltung -- aktueller Stand			      :notes:

Es gibt eine große Anzahl unterschiedlicher
Versionsverwaltungswerkzeuge. Aktuell ist ~git~ sicherlich am
weitesten verbreitet; es ist sehr flexibel und funktionsreich. 

In dieser VL  werden wir allerdings auf explizite
Versionsverwaltungswerkzeuge verzichten. 

** Integrierte Entwicklungsumgebung 

- Integrated Development Environment (IDE) 
- Fasst viele Werkzeuge in einem Programm zusammen
- Problem: Meist *sehr* komplex
  - Bedienung, Nutzung einer IDE zu lernen ist sehr zeitaufwändig
- /IDE-Bedienung ist *nicht* programmieren/!


*** Empfehlung							    :animate:
- Tun Sie es nicht
- Jedenfalls nicht gleich! 

* Programmierung im Kontext 

** Alles alleine? 

- Schreiben Sie alle Programme von Grund auf (/from scratch/)? 

*** Natürlich nicht						    :animate:

- Sie nutzen Arbeit anderer
  - Allgemein verfügbar
  - Aus Ihrem Team
- Sie nutzen Erfahrungen anderer 


** Allgemein verfügbar: Bibliotheken 

- Bibliothek
  - Programmcode der vielen Zwecken dienen kann
  - Teil der Sprache: /Standard-Bibliothek/ 
  - Oder zusätzlich verfügbar 

- Stark unterschiedliche Ansätze zwischen Sprachen
  - C: fast leere Standardbibliothek
  - Python: sehr umfangreich (/batteries included/)


*** Effizienz des Programmierers				    :animate:

- Gute Programmiersprache mit guter Bibliothek!



** Technisch: Package management systems 

- Wie findet man, installiert man zusätzliche Bibliotheken?
  - Bibliothek: /Package/
  - /Package management system/
- Stark unterschiedliche Ansätze zwischen Sprachen
  - C: ???
  - Python: [[https://pypi.python.org/pypi/pip][Python Package Index]] (PIP), [[http://conda.pydata.org/docs/][Conda]], u.a.
- Beispiele: Später 


** Team-Arbeit: Versionsverwaltung 

- Versionsverwaltung auch (insbesondere) für Team-Arbeit gedacht 
- Gemeinsame Arbeit an größerem Projekt
- Wiederverwendung! 
- Beispiele: Später 

** Hilfe finden 

Wo finden Sie Hilfe? Bei allgemeinen Fragen? 

- [[http://stackexchange.com][StackExchange]]
  - Mit spezialisierten Unterseiten für einzelne Gebiete
  - [[http://askubuntu.com][stackOverflow]] -- 4.7 million
    programmers, helping each other 
  - [[http://askubuntu.com][AskUbuntu]]
  - [[http://serverfault.com][System adminstration]]
  - [[http://tex.stackexchange.com][TeX/LaTex StackExchange]] --
    Textverarbeitung für ernsthafte Textverarbeiter
  - [[http://emacs.stackexchange.com][emacs]] -- Editor für ernsthafte Programmierer 

** Hilfe finden (2) 

- Spezifisch: Sprache, Entwicklungsumgebung, ...
  - Beispiel C++: [[http://en.cppreference.com/w/][C++ Reference Site]]



** Gute Programmierer

... wissen, wie man google/stackoverflow die richtigen Fragen stellt 

* Material 

** Programmierung 

- Programmierung allgemein
  - Felleisen et al., [[http://htdp.org][How to design programs, An introduction to
    programming and computing]], MIT Press (online verfügbar). 

- Online

  - [[https://www.codecademy.com/][CodeCademy]]: Große Sammlung von
    Kursen zu unterschiedlichen Themen; interaktiv

  - [[https://www.codewars.com][CodeWars]]: Lernen durch Herausforderungen 

  - s. a. [[http://www.hongkiat.com/blog/sites-to-learn-coding-online/][Übersichtswebsite]];
    meist kommerzielle Angebote 



** Python 

- Python, die Sprache 
  - [[https://docs.python.org/3/][Python Dokumentation]]
  - Mark Lutz, Learning Python, 5th ed., O'Reilly
    - Auch als
      [[http://proquest.tech.safaribooksonline.de/9781449355722][eBook]]
      in der UniBib 
  - Jason Briggs, Python for Kids 
  - Bernd Klein, Einführung in Python 3: In einer Woche programmieren
    lernen 
  - Thomas Theis, Einstieg in Python

** Python, Umgebungen 

- Jupyter
  - [[http://jupyter.org][Jupyter Projekt Webseiten]]
- Texteditor
  - [[http://atom.io][Atom]]
  - [[https://www.gnu.org/s/emacs/][Emacs]]
    - Mit Abarten je nach Betriebssystem
  - und viele, viele andere ... 
- IDEs
  - (Vorsicht, *sehr* komplex) 
  - Kommerziell: [[https://www.jetbrains.com/pycharm/][PyCharm]]
  - Open Source: Eclipse, insbes. [[http://www.pydev.org][PyDev]] 

** Java								       :skip:

- Bücher
  - Hanspeter Mössenböck, Sprechen Sie Java? dpunkt Verlag
  - Reinhard Schiedermeier, Programmieren mit Java, Pearson Studium
- [[http://download.oracle.com/javase/tutorial/][Java Tutorial]]


** Java, Umgebungen						       :skip:


- IDEs
  - (Vorsicht, *sehr* komplex) 
  - Open Source: [[http://www.eclipse.org][Eclipse]] 

* Zusammenfassung 

** Aber das kann ich doch alles 

- Vorkenntnisse vorhanden? *Super*!
- Keine? Auch gut! 
- Selbsteinschätzung -- brauche ich die Vorlesung?
  - Variablen: Referenztypen vs. normale Typen
  - Statisch vs. dynamisch typisierte Sprachen
  - Kontrollstrukturen: ~if~, ~while~, ~for~ mit Iteratoren
  - Algorithmenentwurf mit rekursiven Funktionen
  - Funktionen: Closures, Generatoren
  - Objektorientierung
    - Mehrfachvererbung, Method Resolution Order durch C3-Algorithmus
    - Einfachvererbung: Abstrakte Klassen vs. Interfaces
  - Debugging: Konzepte und Werkzeuge 

** Übung auch bei Vorkenntnissen 

- Sie *müssen* selbst bei perfekten Vorkenntnissen Übungsaufgaben
  abgeben
- Zulassungsvoraussetzung für Klausur!
- Aber das ist dann ja kein Aufwand für Sie! 

** Zusammenfassung 

- Programmieren ist
  - mehr als nur /Coding/
  - ein systematischer Prozess
  - spielt sich in einem gewählten Paradigma ab
- Gute Programmierer
  - sind analytisch und stilistisch sicher 
  - beherrschen wesentliche Werkzeuge
  - kennen den Entwicklungskontext 
