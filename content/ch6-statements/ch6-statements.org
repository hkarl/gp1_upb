#+TITLE: Kapitel 6: Anweisungen -- Teil 1 
#+INCLUDE: "../template/header.org"

#+STARTUP: showeverything
# TODO states: looks like this has to go on main file and cannot be
# included 
#+TODO: TODO(t) | UEBUNG(u) DONE(d)
#+OPTIONS: tasks:todo


* Überblick 


** Setup 						  :skipslide:nolatex:

Main point here is to set up warnings properly for presentation and to
load tutormagic, so that we can later on use pythontutor for code
animations. 
   
#+BEGIN_SRC  Python 
%load_ext tutormagic
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning, module='.*/IPython/.*')
#+END_SRC



** Was bisher geschah 

- Wir können bis jetzt 
  - Werte aufschreiben, was Objekte erzeugt 
  - aus Objekten Ausdrücke für neue Objekte bilden
    - mit Aufruf von Funktionen als Beispiel 
  - mit Namen auf Objekte referenzieren (zuweisen)
    - mit der Definition einer Funktion als Sonderfall
- Also: Folgen von Zuweisungen
  - Die eine nach der anderen ausgeführt werden 

Aber: /Kein Einfluss auf Reihenfolge der Ausführung!/

** Dieses Kapitel  

- Wir nehmen Einfluss auf die Reihenfolge der Ausführung von
  Anweisungen
- Dazu brauchen wir weitere Anweisungen
  - Bedingungen, Schleifen
- Wir verallgemeinern die Vorstellung, was eine Anweisung ist 






* Programm 

** Ein Programm 

- Ein Programm ist eine Folge von Anweisungen
  - Ausgeführt entsprechend des /Ausführungsmodells/
  - Bis jetzt: Sequentiell, Funktionsaufruf 
- Um die Reihenfolge der Anweisungen zu beeinflussen, müssen wir das
  Ausführungsmodell erweitern 

** Anweisungen -- bis jetzt 

- Die Zuweisung ~=~
- Die Funktionsdefinition ~def~
- Der Funktionsaufruf 
- Die Rückkehr aus einer Funktion ~return~

Und die Folge von Anweisungen 
- Erinnerung: Eine Zeile, eine Anweisung! 

** Bedingte Folge von Anweisungen 

Idee: 
- Die Fortsetzung des Programms nicht fest bei der nächsten Anweisung
- Sondern die Wahl der nächsten /auszuführenden/ Anweisung von dem
  Wert eines Ausdrucks abhängig machen 
- /Alternativen/ im Programm vorsehen 


** Schleifen von Anweisungen 

Idee: 
- In der Fortsetzung des Programms erlauben, zu vorherigen Anweisungen
  zurückzukehren
- Meist (nicht unbedingt) abhängig vom Wert eines Ausdrucks 
- /Wiederholungen/ oder /Schleifen/ erlauben 



* Bedingte Ausführung: if

** Neue Anweisung: ~if~

- Die Anweisung ~if~ besteht aus zwei Teilen:
  - Einem Ausdrucks, der auf wahr oder falsch ausgewertet wird
  - Eine Folge von Anweisungen -- der so genannte /*block*/ 
- Semantik: die angegebene Folge von Anweisungen nur ausführen, wenn
  der Ausdruck den Wert wahr hat 

** ~if~: Syntax 

#+BEGIN_SRC python :exports code :results output
  if Ausdruck:
      Anweisung1
      Anweisung2
      usw.

  # if hier zu Ende
  Anweisung nach if
#+END_SRC 

*** Beobachtung
- Das Ende des Ausdrucks wird durch Doppelpunkt ~:~ markiert
- Die durch ~if~ kontrollierten Anweisungen werden /unterhalb/ von
  ~if~ /eingerückt/ aufgeschrieben
- Der Block endet dort, wo die Einrückung endet 



** ~if~: Syntax im Vergleich mit ~def~ 

- Syntax ist der von ~def~ sehr ähnlich
  - Schlüsselwort, dann ein Ausdruck, dann ein Doppelpunkt
  - Dann /eingerückt/ die kontrollierten Anweisungen
  - Ende der Einrückung = Ende des Blocks (~if~, ~def~,
    etc.) 

- Typisches Muster der Syntax von Python! 

** Warum Einrückung?

- Einrückung ist kompakt, leicht lesbar
- /Erzwingt/ ordentliche Struktur des Codes
  - Keine Variationsmöglichkeiten wie in anderen Sprachen
- /Readability counts/ (PEP 20) 


*** Vergleich mit anderen Sprachen				    :dropslide:

Wenn Sie andere Sprachen wie C oder Java kennen, wird Ihnen die
Kompaktheit dieser Formulierung auffallen. Keine runden Klammern um
den Ausdruck erforderlich, keine geschweiften Klammen, um den Beginn
und das Ende der kontrollierten Anweisungen zu kontrollieren. Kein
überschlüssiges Wort ~then~, was in manchen Sprachen vorkommt. 
Insgesamt ist die Syntax von Python sehr knapp und frugal. 







** Alternative: Wahr oder falsch? 

- Erweiterung: Zwei Code-Blöcke, für den Wahr- und den Falsch-Fall 

#+BEGIN_SRC python :exports code :results output
  if Ausdruck:
      # Block für wahr: 
      Anweisung1
      Anweisung2
      ...
  else:
      # Block für falsch:
      Anweisung1
      Anweisung2
      ...

  # Anweisungen nach if/else
  Anweisung1
  ... 
#+END_SRC 

*** Achtung 

Doppelpunkt nach ~else~!

** Alternative: Semantik 

- Der ~Ausdruck~ wird einmal ausgewertet und auf wahr oder falsch
  überprüft
- Danach wird /entweder/ der Wahr-Block /oder/ der Falsch-Block
  ausgeführt 

 
** ~if~: Beispiele  

#+BEGIN_SRC python :exports both :results output
  if True:
      print("Ja!")
#+END_SRC 

#+RESULTS:
: Ja!

#+BEGIN_SRC python :exports both :results output
  if not True:
      print("Ja!")
  else:
      print("Nein!")
#+END_SRC

#+RESULTS:
: Nein!


*** UEBUNG Funktion max3 ohne else 

Ähnlich zu Folie bei Wehrheim 

** ~if~: Beispiel Betrag 

Wie Code ergänzen, um den Betrag einer Zahl zu bestimmen?

#+BEGIN_SRC python :exports both :results output
  def betrag(x):
      """Liefere Absolutbetrag von x"""
      if (???):
          return ???
      else:
          return ???

  print("Betrag von 5: ", betrag(5))
  print("Betrag von -3: ", betrag(-3))
#+END_SRC 

#+RESULTS:

 
** Ausflug: Code testen

Wie sind Sie /sicher/, dass Ihre Lösung stimmt? 
- Erste Idee: Testfälle ausprobieren
- Von Hand? Automatisch! 
- Insbesondere: Randfälle

Aber: /sicher/? Nein... 

** Test-Anweisung: ~assert~					   :subslide:

~assert~: Anweisung, der ein Ausdruck folgt
- Wenn Ausdruck wahr, weitermachen 
- Wenn Ausdruck falsch, mit Fehler abbrechen 

#+BEGIN_SRC python :exports both :results output
  def betrag(x):
      if (x>0):
          return x
      else:
          return -1 * x

  assert 5 == betrag(5)
  assert 7 == betrag(-7)
  assert 0 == betrag(0)
  assert "abc" == betrag("abc")
#+END_SRC 

#+RESULTS:

** Tests für ~quersumme3~					   :subslide:

Was wäre gute ~assert~-Anweisungen für die Funktion ~quersumme3~ aus
vorherigem Kapitel? 

#+BEGIN_SRC python :exports both :results output
  def quersumme3(t):
      return t[0] + t[1] + t[2]

  # Nuetzliche asserts? 
  assert True
#+END_SRC 






** Geschachtelte ~if/else~ 

Beobachtung: 
- ~if/else~ ist eine Anweisung
- Im Block von ~if~ bzw. ~else~ dürfen Anweisungen stehen

*** Darf dann da auch ein ~if/else~ stehen ? 			    :animate:

- Die Logik der Syntax gibt das her 
- Also: *JA!* 

*** UEBUNG if else als Ausdruck 

die KLurzform ~a if c else b~ erkären. 

Insebs.: das ist ein AUSDRUCK und keine Anweisung, kann also an eine
Variable zugewiesen werden. 


** Geschachtelte ~if/else~: Allgemeiner Fall			   :subslide:
 
#+BEGIN_SRC python :exports code :results output
  if Bedingung1:
      Teilblock1
      if Bedingung2:
          Teilblock2
      else:
          Teilblock3
      # Ende des inneren if 
      Teilblock4
  else:
      Teilblock5
      if Bedingung3:
          Teilblock6
      else:
          Teilblock7
      # Ende des zweiten inneren if
      Teilblock8
  # Ende von if 
#+END_SRC 


** Geschachtelte ~if/else~: Einfachere Fälle			   :subslide:

- Die ganzen Teilblöcke dürfen auch leer sein 
- Leerer Teilblock nach ~else~?
  - Dann kann man das ~else~ auch weglassen und nur das ~if~ schreiben


** Leerer Teilblock nach ~if~? 

Würde das gehen? 

#+BEGIN_SRC python :exports code :results output
  if Bedingung:
  else:
      Anweisung
#+END_SRC 

*** Kein leerer Block nach ~if~!				    :animate:

Nein, nach ~if~ *muss* Anweisung folgen! 
- Aber wenn da nichts zu tun ist?
  - Weil Code noch kommt, ... ?
- Sonderanweisung: ~pass~


** ~pass~: Beispiel 

Angenommen, Sie wollen Variable ~laenge~ zwischen auf mindestens 100
aber höchstens 200 begrenzen: 

#+BEGIN_SRC python :exports both :results output
  laenge = 252
  if laenge >= 100:
      if laenge <=200:
          pass
      else:
          laenge = 200
  else:
      laenge = 100
  print(laenge)
#+END_SRC 


** Anweisung: ~pass~						   :subslide:

*** ~pass~						       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

~pass~ ist die leere Anweisung: Sie verändert den Zustand des
Programms nicht und geht zur folgenden Anweisung über. 

~pass~ wird typischerweise benutzt 
- wo die Syntax eine Anweisung vorschreibt aber keine sinnvolle Handlung möglich ist oder
- als  ein Platzhalter für noch zu ergänzenden Code. 


** Eindeutigkeit von ~else~? 

Ist immer eindeutig klar, zu welchem ~if~ ein ~else~ gehört? 

*** Beispiel 1 

#+BEGIN_SRC python :exports code :results output
  if Bedingung1:
      if Bedingung 2:
          Block1
  else:
      Block2 
#+END_SRC 


*** Beispiel 2							    :animate:

#+BEGIN_SRC python :exports code :results output
  if Bedingung1:
      if Bedingung 2:
          Block1
      else:
          Block2 
#+END_SRC 

*** Unproblematisch 

Dank Einrückung ist die Syntax eindeutig 

*** Verschachtelte if/else in anderen Sprachen			  :dropslide:

Auch hier wieder: in anderen Sprachen werden die Blöcke häufig durch
Konstrukte wie geschweifte Klammern markiert. Das ist zwar semantisch
ebenfalls eindeutig, für einen Menschen aber ggf. viel schwer zu lesen
und verwirrend, wenn die optische Einrückung nicht mit der
Klammerstruktur übereinstimmt. Wir werden uns im Java-Teil der
Vorlesung hier noch einige unschöne Beispiele anschauen. 





** Häufiger Fall: Nach ~else~ wieder ein ~if~

- Szenario: /Wenn nicht das, ist dann das der Fall? Und wenn das nicht,
  dann das? ...?/
- Mit ~if/else~ ausdrückbar, aber schrecklich lesbar 

#+BEGIN_SRC python :exports code :results output
  if Bedingung1:
      Anweisung1
  else:
      if Bedingung2:
          Anweisung2
      else:
          if Bedingung3:
              Anweisung3
          else:
              Anweisung4
#+END_SRC 


** Allgemeine Form: ~if/elif/else~ 

Gleicher Effekt, aber knapper: ~elif~ 

#+BEGIN_SRC python :exports code :results output
  if Bedingung1:
      Anweisung1
  elif Bedingung2:
      Anweisung2
  elif Bedingung3:
      Anweisung3
  else:
      Anweisung4
#+END_SRC 

*** Doppelpunkt 

Auf Doppelpunkt nach elif-Bedingung achten! 


** ~if/elif/else~: Beispiel 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 17, 42]
  if len(L) < 3:
      print("zu kurz")
  elif len(L) > 5:
      print("zu lang")
  elif len(L) == 4:
      print("ausgereizt")
  else:
      print("knapp")
#+END_SRC 

#+RESULTS:
: ausgereizt

*** UEBUNG Bedingung nach else? 

Warum darf nach else keine Bedingung stehen? 

*** UEBUNG Auswertung Einfluss auf Bedingungsergebnis? 

- Hat die Ausführung der Blöcke Auswirkungen darauf, welcher Zweig
  genommen wird?
  - Nein, da steht ja fest, was passiert 
- Hat der Test der ersten Bedingung Auswirkung darauf, wlecher Zweig
  genommen wird?
  - Ja, wenn Seiteneffekt vorliegen! z.b. Funktionsaufrufe
  - Beispiel konstruieren lassen!? 

*** UEBUNG switch nachbauen? 

python hat kein switch wie andere Sprachen. Nachbauen? 

Mit ~in~ Test?  Default abzufangen? 

>>> branch = {'spam': 1.25,
...           'ham':  1.99,
...           'eggs': 0.99}

An in membership test in an if statement can have the same default effect:

>>> choice = 'bacon'
>>> if choice in branch:
...     print(branch[choice])
... else:
...     print('Bad choice')
...
Bad choice


*** UEBUNG groeser/gleich/kleiner definieren 

Schreibe Funktion ~vergleich~ die zwei Werte nimmt. Wenn erste größer, gibt
"groesser" zureuck, wenn gleich, "gleich", sonst "kleiner". 

Denken Sie an Randfälle. 

Können Sie etwas sinnvolles  tun, wenn jemand ~vergelich(17, "abc")~
aufruft?  

** Definition: ~if/elif/else~ 
   
*** Anweisung: ~if/elif/else~ 				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Die Anweisung ~if/elif/else~ ermöglichen die alternative Ausführung
einer Folge von Anweisungen -- eines /*Blocks*/ -- in Abhängigkeit des
Wahrheitswertes eine Ausdrucks (~if~) bzw. mehrerer Ausrücke (~if~ und
folgende ~elif~ Ausdrücke). Dem ~if~ kann optional ein oder mehrere
~elif~ und optional höchstens ein ~else~-Teil folgen. 

Die Blöcke werden durch Einrückung den jeweiligen Bedingungen bzw. dem
~else~ zugeordnet. 

*** Definition: Block 

*** Block					       :B_definition:animate:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Ein Block ist eine Folge beliebiger Anweisungen (mindestens eine
Anweisung).  Die Zustandsänderung, die ein Block bewirkt, ist die
Zustandsänderung, die sich durch die sequentielle Ausführung der
Anweisungen des Blocks ergibt. Sequentiell bezieht sich hier auf die
Reihenfolge der Anweisung im Programmcode. 


* Schleifen: while 

** Allgemeine Schleifen 

- Idee: Wiederhole einen Block solange, wie eine Bedingung wahr ist 
- Typisch: Anweisungen im Block werden Einfluss auf den Test haben 
- Grundform: 

#+BEGIN_SRC python :exports code :results output
  while Test
      Block
#+END_SRC 


** ~while~: Flussdiagramm 

#+BEGIN_LaTeX
Abbildung~\ref{fig:while-flowchart} zeigt eine erste Vorstellung einer while-Schleife in Python als Flussdiagramm.  
#+END_LaTeX


   #+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 600 
   #+header: :cache yes
   #+begin_src latex :exports results :results output raw :file figures/while-flowchart.png :fit t
     \usetikzlibrary{shapes,arrows,positioning}
     \tikzset{
       block/.style = {shape=rectangle, 
                          draw, align=left},
       decision/.style     = {block, align=center, diamond, aspect=2},
       arr/.style = {->, thick, }
     }
     \begin{tikzpicture}
     \node [decision] (while) {\texttt{while}};
     \node [left=1cm of while.west] (whiledockl)  {};
     \node [block, below=of while ] (rumpf)
     {\#
       Rumpf\\Anweisung\\Anweisung\\Anweisung};
     \node [below=0.5cm of rumpf.south] (rumpfdock) {};
     \node [block, below right=of rumpf] (after) {\# Nach Schleife\\Anweisung};
     \draw [arr] (while) -- node[near start, right] {Wahr}  (rumpf);
     \draw [arr] (while.east) -| node[near start, above] {Falsch} (after);
     \draw [arr] (rumpf.south) --  (rumpfdock.center)  -| (whiledockl.center)   -- (while.west);
     \end{tikzpicture}
   #+end_src

   #+RESULTS[68c2c177280bf7b2129df78c62ad021d8a5a1394]:
   #+NAME: fig:while-flowchart
   #+CAPTION: Flussdiagramm einer einfachen While-Schleife
   #+ATTR_LaTeX: :caption \caption{Flussdiagramm einer einfachen While-Schleife \label{fig:while-flowchart}}
   #+ATTR_LATEX: :width 0.75\textwidth :float t
   [[file:figures/while-flowchart.png]]


** ~while~: Beispiel Zählschleife 

#+BEGIN_SRC python :exports both :results output
a=0
b=5
while a < b:              
    print(a, end=" ")
    a += 1         
#+END_SRC 

#+RESULTS:
: 0 1 2 3 4 


** Beobachtung: Sichtbarkeit von Variablen 

- Vorheriges Beispiel: Auf Variable ~a~ wurde innerhalb der Schleife
  zugegriffen
- Offenbar unproblematisch 
- Regel: Schon /vor/ der Schleife bekannte Variablen bleiben innerhalb
  des Blocks /sichtbar/
  - Sie sind im gleichen /Scope/ (und auch im gleichen Namensraum)


** Beobachtung: Sichtbarkeit von Variablen (2)			   :subslide:

- Was ist umgekehrt? Variable wird erst in Schleife erzeugt? 

#+BEGIN_SRC python :exports both :results output
  i = 0
  while i < 2:
      i += 1
      x = 2*i
  print(x)
#+END_SRC 

#+RESULTS:
: 4

*** Variable nach Schleife sichtbar				    :animate:

- Variable bleibt nach der Schleife erhalten und zeigt auf
  entsprechenden Wert  

** Schleifen: Terminierung 

Gefahr: Schleifenbedingung stets wahr 
- Schleife wird nicht verlassen
- Programm /in Endlosschleife/

** Einfache Regeln für Terminierung 

Schleife terminiert bestimmt, wenn es
- eine Variable gibt, die in jedem Schleifendurchlauf /streng monoton/
  wächst und 
- die Variable /diskret/ wächst und 
- die Schleifenbedingung eine obere Schranke darstellt

Analog: Variable schrumpft, untere Schranke 

*** UEBUNG Warum diskret? 

Ist die Forderung wächst diskret im Prinzip wichtig? 

und bei realer Rechnerarithmetik? 

aber dann auch praktikabel ? 

Beispiel: i=0 ; while 1/i > 0 ; i++ 



*** UEBUNG Viele Schleifenbeispiele 

Fibonacci, usw. 


** Terminierung ist kritisch!					   :subslide:

Q. How did the programmer die in the shower?

A. He read the shampoo bottle instructions: Lather. Rinse. Repeat.


** Beispiel: GGT 

Bestimme den größten gemeinsamen Teiler 

#+BEGIN_SRC python :exports both :results output
  a = 18
  b = 12
  while (a != b):
      if a>b:
          a = a-b
      else:
          b = b-a
#+END_SRC 

Terminiert für alle Eingaben? 

*** UEBUNG Weiter Beispiele 

Z.b. Collatz-folge. Zineszins-Jahresanzahl, ... 

** ~while~: Schleife über Feld 

Beispiel: Werte in einer Liste aufaddieren 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4]
  i = 0
  sum = 0
  while i < len(L):
      sum = sum + L[i]
      i = i + 1
  print(sum) 
#+END_SRC 

#+RESULTS:
: 10

*** Nicht pythonisch					       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
Das ist nicht Python-Style (/pythonic/). Hier nur als didaktischer
Zwischenschritt!

** ~while~: Beispiel Suchschleife 

Szenario: 
- Wir haben eine Liste (oder Tuple) 
- Wir suchen ein Element mit einer bestimmten Eigenschaft
  - Allgemeiner als mit ~index~ machbar: da nur Identität als
    Eigenschaft möglich 

Idee: 
- Mit einer Schleife die Elemente ablaufen
- Testen, ob Eigenschaft erfüllt
  - Merken, dass gefunden

** ~while~: Beispiel Suchschleife  (2)				   :subslide:


#+BEGIN_SRC python :exports both :results output
  # ist eine ungerade Zahl in L? 
  def ungerade_in_liste(L):
      gefunden = False
      i = 0
      while i < len(L):
          if L[i] % 2 == 1:
              gefunden = True
          i = i + 1
      return gefunden

  print (ungerade_in_liste([2, 18, 6, 5, 9]))
  print (ungerade_in_liste([2, 18, 6, 10, 22]))
#+END_SRC 

#+RESULTS:
: True
: False


*** Beobachtung							    :animate:
- /Alle/ Elemente untersuchen?
  - Nein, nach erstem Finden aufhören? 
 

** ~while~: Beispiel Suchschleife  (2)				   :subslide:


Zusätzliches Abbruchkriterium: ~not gefunden~

#+BEGIN_SRC python :exports both :results output
  # ist eine ungerade Zahl in L? 
  def ungerade_in_liste(L):
      gefunden = False
      i = 0
      while (not gefunden) and (i < len(L)):
          if L[i] % 2 == 1:
              gefunden = True
          i = i + 1
      return gefunden

  print (ungerade_in_liste([2, 18, 6, 5, 9]))
  print (ungerade_in_liste([2, 18, 6, 10, 22]))
#+END_SRC 

** Schleifenbedingungen finden? 

Inspiration? Oder strukturiertes Vorgehen? 

- Idee: *Nach* der Schleife soll irgendeine Zielbedingung gelten
- *Während* der Schleife gilt die Schleifenbedingung 
- Schön wäre: Negation der Schleifenbedingung ist Zielbedingung?
  - Oder: impliziert Zielbedingung? 


** Schleifenbedingungen finden? (2)				   :subslide:


Oft praktisch: Schleifenbedingung konstruieren aus zwei Teilen
- Die /Zielbedingung/ an sich
  - Oder eine stärkere Variante davon 
- Eine /Invariante/: Gilt vor, während, nach der Schleife
  - Stellt sicher, dass alle Anweisungen innerhalb der Anweisung
    korrekt ausgeführt werden können
  - Beispiel: Index für Listenzugriffe gültig 


~Schleifenbedingung = (not Zielbedingung) and Invariante~
- ~Invariante~ kann oft entfallen 


** Schleifenbedingung finden? (3)				   :subslide:

Mit ~Schleifenbedingung = (not Zielbedingung) and Invariante~ nach
Schleife gilt: 

~Zielbedingung or (not Invariante)~ 


*** Was gilt also? 						    :animate:

D.h.: Nach Schleife *nicht* klar, was eigentlich der Fall ist!? 
- Es könnte die Zielbedingung gelten 
- Es könnte aber auch die Invariante verletzt sein 

Also unklar! 

** Nach Schleife: Prüfen! 

Wenn also unklar ist, weswegen die Schleife beendet wurde
- also wegen Erreichen der Zielbedingung
- oder Verletzten der Invariante 

Dann muss man ggf. nach der Schleife nachprüfen! 
- *Häufiges Muster*: Zielbedingung durch Variable explizit darstellen 
- Wie im Beispiel oben: ~gefunden~


** Schleifen: Hilfskonstrukte 

Innerhalb einer Schleife kann viel passieren 

- Wirklich jede Iteration komplett durchlaufen? 
- Eine Schleife abbrechen? 


** Schleifeniterationen nicht komplett durchlaufen		   :subslide:

Typisches Muster:  Umständlich 

#+BEGIN_SRC python :exports code :results output
  while Schleifenbedingung:
      Anweisungen
      if Andere_Bedingung:
          # Lasse den Rest der Schleife aus 
          pass
      else:
          Restliche Anweisungen 
#+END_SRC 

** Schleifeniterationen nicht komplett durchlaufen: ~continue~	   :subslide:

Gleich, aber knapper: 

#+BEGIN_SRC python :exports code :results output
  while Schleifenbedingung:
      Anweisungen
      if Andere_Bedingung:
          continue
      Restliche Anweisungen 
#+END_SRC 


*** UEBUNG continue bei geschachtelten Schleifen? 


** Schleife abbrechen						   :subslide:

Typisches Muster:  Umständlich 

#+BEGIN_SRC python :exports code :results output
  while (not Abbruchsbedingung) and WeitereBedingung:
      Anweisungen
      if Abbruchsbedingungen:
          pass
      else:
          Restliche Anweisungen
#+END_SRC 


** Schleife abbrechen: ~break~					   :subslide:

Gleich, aber knapper: 


#+BEGIN_SRC python :exports code :results output
  while WeitereBedingung:
      Anweisungen
      if Abbruchsbedingungen:
          break
      Restliche Anweisungen
#+END_SRC 


*** Bedingung genau beachten				       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Vorsicht, das Weglassen der Abbruchsbedingung aus der
Schleifenbedingung im Einzelfall genau überlegen. 


*** UEBUNG break bei geschachtelten Schleifen? 


** Reguläre Beendigung vs. ~break~: Reaktion			   :subslide:

Unterschiedliches Beenden einer Schleife kann unterschiedliche
Reaktionen erfordern -- siehe oben 

Unterstützung: ~else~ für Schleife! 

** ~else~ bei Schleifen

Beispiel: 

#+BEGIN_SRC python :exports code :results output
  def is_prime(n):
      """Ist n eine Primzahl?"""
      x = n // 2                                # For some n > 1
      while x > 1:
          if n % x == 0:                        # Remainder
              print(n, 'hat Teiler', x)
              break                             # Skip else
          x -= 1
      else:                                     # Normal exit
          print(n, 'ist eine Primzahl')

  print("Ist 5 eine Primzahl?")        
  is_prime(5)
  print("Ist 9 eine Primzahl?")        
  is_prime(9)
#+END_SRC 

#+RESULTS:
: Ist 5 eine Primzahl?
: 5 ist eine Primzahl
: Ist 9 eine Primzahl?
: 9 hat Teiler 3

*** UEBUNG Warum // und nicht / ? Was ist Unterschied 

*** UEBUNG Ohne else umschreiben 

Schreiben Sie is_prime mit while-Schleife ohne else. Vergliechen Sie
code-Komplexität 

*** UEBUNG assert fuer is_prime 

- Was sind sinnvolle Asserts für is_prime? (oder vorgeben?)
- Bei welchen versagt das?
- Wie müssen Sie is_prime verbessern? 

** ~else~ bei Schleifen (2)					   :subslide:

- Vorteil: Keine Test-Variable nötig
  - Vereinfacht Schleifenbedingung
  - Vereinfacht Anweisungen in der Schleife
  - Wohldefinierte Art, Anweisungen für einen typischen Fall zu
    platzieren -- leichte Lesbarkeit durch Konvention 
 

** ~while~: Suchschleife mit ~else~				   :subslide:


#+BEGIN_SRC python :exports both :results output
  # ist eine ungerade Zahl in L? 
  def ungerade_in_liste(L):
      i = 0
      while (i < len(L)):
          if L[i] % 2 == 1:
              break
          i = i + 1
      else:
          print("nix ungerades!")
          return False
    
      return True 

  print(ungerade_in_liste([2, 18, 6, 5, 9]))
  print(ungerade_in_liste([2, 18, 6, 10, 22]))
#+END_SRC 

#+RESULTS:
: True
: nix ungerades!
: False


*** ~while~ und ~else~: Sinnvoll?				  :dropslide:

In den hier gezeigten, kleinen Beispielen ist der Einsatz von ~else~
möglicherweise nicht vollständig überzeugend. Der Nutzen wird wirklich
klar, wenn im ~else~-Teil einer Schleife nicht-triviale Operationen
durchlaufen werden müssen, zum Beispiel eine Fehlerbehandlung, weitere
Verarbeitungsschritte, etc. Wir kommen in den Übungsaufgaben darauf
zurück. 

*** UEBUNG while / else Beispiele  

So was schön kompaktes habe ich jetzt leider auch nicht zur Hand :-(. 

** Stil: ~continue~, ~break~ ? 

Ist das überhaupt guter Stil? Wird das Programm unstrukturiert? 

- Das ist beinahe Glaubenssache
- Aber ~break~ und ~continue~ haben klar definiertes Verhalten
- Insbesondere in Verbindung mit ~else~ alle Fälle eines
  Schleifenendes im Programmcode klar identifizierbar

Also: Ja, das ist ok! Mit Verständnis!  

** Stil: goto							   :subslide:

Goto considered harmful 

#+CAPTION: goto considered harmful 
#+ATTR_LaTeX: :width 0.50\linewidth
#+NAME: fig:goto-saurier
[[./figures/goto.png]]






** Definition: ~while~ 

*** ~while~						       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:


Eine ~while~-Schleife besteht aus einem Ausdruck als /Test/
(/Schleifenbedingung/) und einem /Rumpf/ (/Schleifenrumpf/,
/Schleifenkörper/). Beim Einreichen der ~while~-Anweisung wird der
Test-Ausdruck ausgewertet und mit dem booleschen Wert ~True~
verglichen. Ist der Test-Ausdruck wahr, wird der Rumpf einmal
ausgeführt; die Veränderungen des Zustands durch die Anweisungen des
Rumpfs sind (natürlich) wirksam. 

Danach wird wie beim Erreichen der ~while~-Anweisung verfahren: Der
Test wird (aufgrund der neuen Variablen-Werte) ausgewertet und
ggf. der Rumpf ausgeführt. 


Der Rest einer Schleifeniteration kann durch die Anweisung ~continue~
übersprungen werden und mit der folgenden Iteration begonnen
werden. Eine Schleife kann mit der Anweisung ~break~ abgebrochen
werden. 

Am Ende einer regulär (nicht durch ~break~) beendeten Schleife wird
ein ggf. vorhandener Block nach der Anweisung ~else~ ausgeführt. Bei
Beendung der Schleife durch ~break~ wird dieser Block ignoriert. 

** ~while~: Komplettes Flussdiagramm 


#+BEGIN_LaTeX
Abbildung~\ref{fig:while-flowchart-complete} zeigt ein vollständiges Flussdiagramm einer while-Schleife in Python. 
#+END_LaTeX

   #+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 600 
   #+header: :cache yes
   #+begin_src latex :exports results :results output raw :file figures/while-flowchart-complete.png :fit t
     \usetikzlibrary{shapes,arrows,positioning}
     \tikzset{
       block/.style = {shape=rectangle, 
                          draw, align=left},
       decision/.style     = {block, align=center, diamond, aspect=2},
       arr/.style = {->, thick, }
     }
     \begin{tikzpicture}
     \node [decision] (while) {\texttt{while}};
     \node [left=1cm of while.west] (whiledockl)  {};
     \node [left=0.5cm of while.west] (whiledockr)  {};
     \node [block, below=of while ] (rumpf)
     {\#
       Rumpf\\Anweisung\\\texttt{continue}\\Anweisung\\\texttt{break}\\Anweisung};
     \node [below=0.5cm of rumpf.south] (rumpfdock) {};
     \node [block, right=of rumpf] (else)  {\texttt{else:}\\Anweisung};
     \node [block, below=of else] (after) {\# Nach Schleife\\Anweisung};
     \draw [arr] (while) -- node[near start, right] {Wahr}  (rumpf);
     \draw [arr] (while.east) -| node[near start, above] {Falsch} (else);
     \draw [arr] (else) -- (after);
     \draw [arr,blue] ([xshift=0.1cm, yshift=0.2cm]rumpf.west) -| (whiledockr.center)   -- (while.west);
     \draw [arr] (rumpf.south) --  (rumpfdock.center)  -| (whiledockl.center)   -- (while.west);
     \draw [arr,red] ([xshift=-0.3cm,yshift=-0.6cm]rumpf.east) -- (after);
     \end{tikzpicture}
   #+end_src

   #+RESULTS[e7ec553ca1223ed541d99d1ff12639a47af711ba]:
   #+NAME: fig:while-flowchart-complete
   #+CAPTION: Flussdiagramm einer While-Schleife mit ~continue~, ~break~ und ~else~
   #+ATTR_LaTeX: :caption \caption{Flussdiagramm einer While-Schleife mit ~continue~, ~break~ und ~else~ \label{fig:while-flowchart-complete}}
   #+ATTR_LATEX: :width 0.75\textwidth :float t
   [[file:figures/while-flowchart-complete.png]]


* Schleifen: for


** Häufiger Fall: Schleife über Aufzählung 

Häufig: Eine Aufzählung (Liste, Tuple, usw) Element für Element
verarbeiten 

Skizze: 
#+BEGIN_SRC python :exports code :results output
  L = [1, 2, 3, 4, 5]
  while L is not []:
      aktuellesElement = L[0]
      # mache etwas mir aktuellem Element
      # ...
      # betrachte die restlichte Liste: 
      L = L[1:]
#+END_SRC 

*** Keine korrekte Schleife!			       :B_alertblock:animate:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Dies ist *keine* korrekte Schleife; sie hat mindestens *zwei*
Probleme. Siehe Details in der Übungsaufgabe. 

*** UEBUNG WArum funktioniert dieser Pseudo-Code nicht direkt? 

WICHTIGE Übung! 

- Weil Behandlung für letztes Element fehlt 
- Weil wir L verändern; wir müssten vorher eine Kopie machen 

** Häufige Fälle verdienen eigene Anweisung: ~for~

Schleifen über Aufzählungen vereinfacht schreiben

#+BEGIN_SRC python :exports both :results output
  # Sei A ein Aufzählungsdatentyp
  for element in A:
      Anweisung1
      Anweisung2
      ... 
#+END_SRC 

** ~for~: Definition 

*** ~for~-Schleife					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Mit jeder Iteration einer ~for~ Schleife wird das jeweils nächste
  Element der gegeben Aufzählung der /Schleifenvariable/ (auch
  /Laufvariable/)zugewiesen
  (im Beispiel: ~element~; Name ist frei wählbar)
- Nach Bearbeitung des letzten Elements der Aufzählung wird die
  Schleife verlassen
- Ist die Aufzählung leer (z.B. ~[]~), so wird die Schleife nicht
  betreten und keine Iteration ausgeführt 
- Die Anweisungen ~break~, ~continue~ und ~else~ verhalten sich genau wie bei
  ~while~-Schleifen




*** UEBUNG Einfaches Beispiel: mit SChleife mit zwei Laufvariablen über dict.key, dict.values iterieren 

** Zuweisung an Aufzählung? 

Was passiert, wenn der Aufzählung einer neuer Wert zugewiesen wird?
- Ändert das den Schleifenverlauf? 
- Beispiel: 

#+BEGIN_SRC python :exports both :results output
L = [1, 2, 3]
for l in L:
    print(l, end=" ")
    L = [17, 18, 19]
#+END_SRC 

#+RESULTS:
: 1 2 3 

** Zuweisung an Aufzählung -- passiert gar nicht!		   :subslide:

- Tatsächlich kann an die Aufzählung, die für die Schleife verwendet
  wird, gar nicht zugewiesen werden 
- Zu Beginn der ~for~-Schleife wird eine /Kopie/ der Aufzählung
  erstellt
  - Kopie wird unter einem verborgenen Namen referenziert
  - Diese Kopie bestimmt, welche Werte die Schleife durchläuft 
- Weißt man also einer Variable, die im Schleifenkopf benutzt wird,
  einen neuen Wert zu, so beeinflusst das nicht den Schleifenablauf
  - Die Kopie wird ja dadurch nicht verändert 


*** Visualisierung						  :dropslide:

Die Visualisierung dieses Effekts durch unsere üblichen Diagramme
gelingt leider nicht gut (Abbildung [[fig:pt-zuweisung-for]]). Der
verborgene Name für die Aufzählung wird durch Pythontutor leider nicht
explizit dargestellt. Dennoch hilft dieses Diagramm vielleicht ein
wenig.

#+CAPTION: Zuweisung an Aufzählung während while-Schleife
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-zuweisung-for
[[./figures/pt-zuweisung-for.png]]


** Zuweisung an Schleifenvariable				   :subslide:

Was passiert, wenn der Schleifenvariable etwas zugewiesen wird? 
- Ändert das die Aufzählung? Den Schleifenverlauf? 
- Beispiel: 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4, 5]
  for x in L:
      x += 1
  print(L)
#+END_SRC 

#+RESULTS:
: [1, 2, 3, 4, 5]


*** Nein!							    :animate:

Auch hier ist die ursprüngliche Aufzählung nicht betroffen 
- Die Schleifenvariable ~x~ ist ein Name für den Wert; zeigt nicht in
  die Aufzählungsstruktur 


** Schleifenvariable nach Schleifenende?			   :subslide:

Bleibt Schleifenvariable erhalten nach Schleifenende? 

#+BEGIN_SRC python :exports both :results output
  for i in [1, 2, 3]:
      print("in schleife")
  print("Variable i nach Schleife: ", i)
#+END_SRC 

#+RESULTS:
: in schleife
: in schleife
: in schleife
: Variable i nach Schleife:  3

*** Ja								    :animate:

- Mit Wert des letzten Durchlaufs


** ~for~-Schleifen über andere Aufzählungen 

- Beispiele bisher: ~for~ über Liste 
- Laut Kapitel 5: Andere Aufzählungen sind ~str~, ~tuple~, ~set~
  - Und eigentlich auch ~dict~
- ~for~-Schleifen darüber? 


** ~for~-Schleifen über andere Aufzählungen -- Beispiele	   :subslide:


#+BEGIN_SRC python :exports both :results output
  s = "Hallo GP1"
  for ss in s:
      print(ss, end=" ")
#+END_SRC 

#+RESULTS:
: H a l l o   G P 1 


#+BEGIN_SRC python :exports both :results output
t = (1, 2, 3, 4)
for tt in t:
    print(tt, end=" ")
#+END_SRC 

#+RESULTS:
: 1 2 3 4 

** ~for~-Schleifen über andere Aufzählungen -- Beispiele	   :subslide:

- Überraschend? Nein!
  - Principle of least surprise 



#+BEGIN_SRC python :exports both :results output
s = {1, 2, 3, 4, 2, 3, 4}
for ss in s:
    print(ss, end=" ")
#+END_SRC 

#+RESULTS:
: 1 2 3 4 

- Überraschend? Nein!
  - Semantik einer Menge 

*** TODO slido? 


** ~for~-Schleife über verschachtelte Datentypen 

Beispiel: Liste von Tupeln 

#+BEGIN_SRC python :exports both :results output
  L = [ (1,2), (3, 4), (5, 6)]
  for t in L:
      print(t, end=" ")
#+END_SRC 

#+RESULTS:
: (1, 2) (3, 4) (5, 6) 

** ~for~-Schleife mit erweiterter Zuweisung? 

- Eigentlich macht ja eine ~for~-Schleife jeweils eine Zuweisung an
  die Laufvariable
- Python kennt erweiterte Zuweisungen und unpacking: ~x, y = (1, 2)~
- Funktioniert das bei ~for~? 


#+BEGIN_SRC python :exports both :results output
  L = [ (1,2), (3, 4), (5, 6)]
  for a, b in L:
      print(a, end=" ")
      print(b)
      print("---")
#+END_SRC 

#+RESULTS:
: 1 2
: ---
: 3 4
: ---
: 5 6
: ---


** ~for~-Schleife über ~dict~ ? 

- Iterieren über ein ~dict~ liefert die Schlüssel 

#+BEGIN_SRC python :exports both :results output
  D = {"a": 1, "b": 2, "c": 3, "d": "abc"}
  for key in D:
      print(key, end=" ")
#+END_SRC 

#+RESULTS:
: a b c d 




** ~for~-Schleife über ~dict~ -- Key und Value?			   :subslide:

Wir bekommen eine Liste von Schlüssel-/Wert-Tuple eines ~dicts~ mit
Aufruf  von ~items~
- Mit implizitem unpacking der Tuple in separate Variablen ~k~ und
  ~v~

#+BEGIN_SRC python :exports both :results output
  D = {"a": 1, "b": 2, "c": 3, "d": "abc"}
  for key, value in D.items():
      print(key, end=" ")
      print(value)
      print("----")
#+END_SRC 

#+RESULTS:
: b 2
: ----
: d abc
: ----
: a 1
: ----
: c 3
: ----


*** Visualisierung						  :dropslide:


Zur Illustration (Abbildung [[fig:pt-dict_items]]) hier ein Schnappschuss
aus dem zweiten Durchlauf der Schleife. Die beiden Schleifenvariablen
~key~ und ~value~ referenzieren dabei Werte aus dem Dictionary ~D~.

#+CAPTION: Zwischenstand bei einer Iteration über ein Dict ~D.items()~
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pt-dict_items
[[./figures/pt-dict_items.png]]


** UEBUNG for-Schleife Übungen 

- Unmengen an Übungen für die ganzen SChleifen 

- Matrizenoperationen realisieren 


- Z.B. die extended assignment sequecnes aus dem ebook 

#+BEGIN_SRC python :exports both :results output
for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
     print(a, b, c)
#+END_SRC 

#+RESULTS:
: 1 [2, 3] 4
: 5 [6, 7] 8


** ~for~ über Folge von Zahlen: ~range~ 

- Häufig: Liste über eine Folge Zahlen 
  - Z.B. 1 ... 10, 1 ... n für Variable n, usw 
- Mit ~for~ so nicht unmittelbar darstellbar
  - Mit ~while~ schon, aber umständlich 

*** ~range~						       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

~range(stop)~ liefert eine Aufzählung der Zahlen von 0 bis
(ausschliesslich) ~stop~

*** UEBUNG allgemeinere Version von range 

range(start, stop[, step]) -> range object

** ~range~: Beispiel						   :subslide:

#+BEGIN_SRC python :exports both :results output
  for i in range(11):
      print(i, end=" ")
#+END_SRC 

#+RESULTS:
: 0 1 2 3 4 5 6 7 8 9 10 


*** UEBUNG Vergleiche Iteration über SEquenz mit range, vs. natürlich

Den Unterschied erklären zwischen den beidne Optionen. Warum ist die
range-Variante doof (aber in primitiven Sprachen geht es halt manchmal
nicht anders): 

#+BEGIN_SRC python :exports both :results output
  s = "Hallo GP1"
  for i in range(len(s)):
      print(s[i], end="")
#+END_SRC 

#+RESULTS:
: Hallo GP1



#+BEGIN_SRC python :exports both :results output
  for c in "Hallo GP1":
      print(c, end="")
#+END_SRC 

#+RESULTS:
: Hallo GP1


Und das ganze evtl .mit Zeitmessung verbinden? Siehe magic %timeit 
https://ipython.org/ipython-doc/3/interactive/magics.html 


mit S = "abcdefg" * 10000


*** UEBUNG Zeichenketten umkehren 

>>> S = 'spam'
>>> for i in range(len(S)):       # For repeat counts 0..3
...     S = S[1:] + S[:1]         # Move front item to end
...     print(S, end=' ')
...
pams amsp mspa spam

>>> S
'spam'
>>> for i in range(len(S)):       # For positions 0..3
...     X = S[i:] + S[:i]         # Rear part + front part
...     print(X, end=' ')





** ~range~: Wie viele Durchläufe?				   :subslide:

Fencepost-Problem: Wie viele Pfähle braucht man für einen 100m langen
Zaun mit Pfählen im Abstand von 10m? 
- 9, 10, 11? 

*** Also für ~range~? 						    :animate:

- ~for i in range(??)~

*** pingo? 


** Terminierung von ~for~ und  ~range~				   :subslide:

Terminiert das hier? 

#+BEGIN_SRC python :exports code :results output
  for i in range(5):
      i -= 1
#+END_SRC 

*** Terminierung von range					    :animate:

Natürlich terminiert das. Der Schleifenstruktur ist egal, was
innerhalb der Schleife mit dem Namen ~i~ gemacht wird (genauer: auf
welchen Wert der Name ~i~ referenziert). Am Ende der Schleife wird der
nächste Wert aus der Aufzählung verwendet. 

** ~range~: Aufzählung verändern				   :subslide:

Erinnerung: Das hier verändert die Aufzählung ~L~ *nicht* 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4, 5]
  for x in L:
      x += 1
  print(L)
#+END_SRC 

*** ~L~ verändern?						    :animate:

Was aber, wenn Schleife doch ~L~ verändern soll? 

** ~range~: Aufzählung verändern				   :subslide:


Dann brauchen wir eine ~for~-Schleife mit Zugriff auf ~L~ durch den
Index 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4, 5]
  for i in range(len(L)):
      L[i] += 1
  print(L)
#+END_SRC 

#+RESULTS:
: [2, 3, 4, 5, 6]


*** Muster							    :animate:

Typisches Muster für den Einsatz von ~range~ und ~len~ in
~for~-Schleifen 
- Durch Struktur der ~for~-Schleife Indiz an Leser des Codes! 

** Aufzählung in ~for~ -- duck typing? 

Im Kopf der ~for~-Schleife: 
- Muss es eine Aufzählung sein?
- Oder -- nach duck typing-Prinzip -- reicht etwas, dass sich wie eine
  Aufzählung benimmt?
  - Dafür haben wir noch kein Beispiel -- aber vielleicht ein
    interessanter Gedanke!

** UEBUNG for loops und zip 

Funktion zip erklären. Beispiele finden, wo man mit ~for x, y in
zip(L1, L2)~ was schönes machen kann. 

** UEBUNG Nachtrag: zip und dict 

Typisches Muster: ~D = dict(zip(keys, vals))~ 


** UEBUNG ~enumerate~ in ~for~

>>> S = 'spam'
>>> for (offset, item) in enumerate(S):
...     print(item, 'appears at offset', offset)

Oder: Liste ausdrucken, nach jedem fünften Element neue Zeile? 

** Beispiel: Sieb des Erathostenes 

- Bestimme alle Primzahlen bis zu einer gegebenen Obergrenze ~n~ 
- Idee:
  - Schreibe alle Zahlen von 2 bis ~n~
  - Nimm die erste Zahl (die 2); streiche alle Vielfachen dieser Zahl
    aus der Tabelle
  - Nimm die nächste noch nicht gestrichene Zahl und wiederhole
    Prozedur
  - Bis keine nicht gestrichene Zahl mehr übrig
  

** Eratostenes: Umsetzung					   :subslide:

- Wie Tabelle repräsentieren?
  - Als Liste der Zahlen: ~[2, 3, 4, 5, ... ]~
    - Möglich, aber dann Suche nach Vielfachen aufwändig
  - Als Liste von gestrichen/nicht gestrichen Werte, mit Zugriff per
    Index
    - nicht/gestrichen als ~True~ oder ~False~ repräsentieren 

** Erathostenes: Code						   :subslide:

#+BEGIN_SRC python :exports both :results output
  n = 20
  prim = n * [True]
  for i in range(n):
      if i==0 or i==1:
          continue
      if prim[i] == True:
          for streich in range(2*i, n, i):
              prim[streich] = False

  print(prim)
#+END_SRC 

#+RESULTS:
: [True, True, True, True, False, True, False, True, False, False, False, True, False, True, False, False, False, True, False, True]


*** UEBUNG Schöner schreiben!

mit ~enumerate~ die Ausgabe schäner machen! Und nur die Primzahlen
ausgebnen, keine Liste. 

** ~while~ oder ~for~ ?

- Ist eine Aufzählung abzuarbeiten; ist eine feste Anzahl an
  Durchläufen bekannt? Dann ~for~
- Ist nur eine Abbruchbedingung bekannt, bei unklarer Anzahl an
  Durchläufen? Dann ~while~


* List comprehensions 



** Listen in Schleife konstruieren 


- Häufiges Muster:
  - Eine Schleife produziert Ergebnis pro Druchlauf
  - Ergebnisse werden in Liste aufgesammelt 
- Einfachster Fall: Einen Ausdruck für jedes Element der Aufzählung
  berechnen 

#+BEGIN_SRC python :exports code :results output
  # leere Liste zum Ergebnisse sammeln: 
  ergebnis = []
  for x in aufzaehlung:
      ergebnis.append(Ausdruck ueber x)
#+END_SRC 

** Listen in Schleife konstruieren -- Beispiel			   :subslide:

Beispiel: Wir verdoppeln jeden Eintrag der Liste 

#+BEGIN_SRC python :exports both :results output
  ergebnis = []
  for x in [1, 2, 3, "abc", "xyz"]:
      ergebnis.append(x * 2)
  print(ergebnis)
#+END_SRC 

#+RESULTS:
: [2, 4, 6, 'abcabc', 'xyzxyz']


** Listen in Schleifen bedingt konstruieren 

- Auch häufig: Pro Durchlauf Ergbnis nur bei bestimmer Bedingung
  konstruieren 

#+BEGIN_SRC python :exports code :results output
  # leere Liste zum Ergebnisse sammeln: 
  ergebnis = []
  for x in aufzaehlung:
      if x erfuellt Bedingung: 
          ergebnis.append(Ausdruck ueber x)
#+END_SRC 


** Listen in Schleifen bedingt konstruieren -- Beispiel		   :subslide:

Verdopple Eintrag nur wenn gerade Zahl: 

#+BEGIN_SRC python :exports both :results output
  ergebnis = []
  for x in [1, 2, 3, 17, 42, 99]:
      if x % 2 == 0:
          ergebnis.append(x * 2)
  print(ergebnis)
#+END_SRC 

#+RESULTS:
: [4, 84]

** List comprehensions 

Wie üblich: Häufige Muster verdienen eigene Syntax! 

List comprehension: 
- Konstruieren eine Liste aus einer anderen Liste
- mit einer kompakten ~for~-Formulierung 

#+BEGIN_SRC python :exports code :results output
[Ausdruck ueber x  for x in Liste if x erfuellt Bedingung]
#+END_SRC 

*** Schleifenvariable						    :animate:

Natürlich auch andere Variablennamen als ~x~ möglich 

** List comprehension -- Beispiel 1				   :subslide:

Verdopple Eintrag nur wenn gerade Zahl: 

#+BEGIN_SRC python :exports both :results output
  # Zeilenumbruch nur für Lesbarkeit
  ergebnis = [x * 2
              for x in [1, 2, 3, 17, 42, 99]
              if x % 2 == 0]
  print(ergebnis)
#+END_SRC 

#+RESULTS:
: [4, 84]


** Beispiel 2							   :subslide:

- Liste der Noten von Austauschstudierenden 

#+BEGIN_SRC python :exports both :results output
  # Liste mit Matrikelnummern: 
  austausch = [11, 22, 33]
  # Dict mit Matrikelnummer: Note Abbildung 
  noten = {11: 2.0, 17: 1.7, 20: 3.3, 22: 1.0, 27: 5.0, 33: 2.3}
  # Liste der Noten der Austauschstudierenden:
  austauschnoten = [noten[a] for a in austausch]
  print(austauschnoten)
#+END_SRC 

#+RESULTS:
: [2.0, 1.0, 2.3]

*** Fehler?							    :animate:

Was passiert, wenn Matrikelnummer fehlt? 


** UEBUNG List comprehesion, ändern der Liste? 


Erinnern Sie sich an : 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4, 5]
  for i in range(len(L)):
      L[i] += 1
  print(L)
#+END_SRC 


Ist das hier das gleiche: 

#+BEGIN_SRC python :exports both :results output
  L = [1, 2, 3, 4, 5]
  L = [x+1 for x in L]
  print(L)
#+END_SRC 

#+RESULTS:
: [2, 3, 4, 5, 6]

Finden Sie Situationen, wo diese beiden Code-Abschnitte *nicht* den
gleichen Effekt haben. Hinweis: Was ist, wenn es andere Namen für die
ursprünliche Liste gibt?


** UEBUNG Liust comprehension als Aufzählung der for-Schleife 

Z.B. Schleife, die über die Vielfachen von drei aufzählt. 

Hier auch wieder fencepost Problem aufbringen 

#+BEGIN_SRC python :exports both :results output
for i in [3*x for x in range(5)]:
    print(i)
#+END_SRC 




* Geschachtelte Schleifen 

** Geschachtelte Schleifen 

- Schleifenrumpf: Folge von Anweisungen 
- Schleifen (~while~ und ~for~) sind Anweisungen
- Also: Schleifen in Schleifen möglich!? 

- Na klar! 

** Paarweise Operation 

- Angenommen, wir wollen Elemente zweiter Listen paarweise miteinander
  vergleichen 
  - Schleife 1 (/äußere/ Schleife): Iteriere über eine Liste
  - Schleife 2 (/innere/ Schleife): In jeder Iteration der äußteren
    Schleife, iteriere über die zweite Schleife
    - Führe Operation durch 

#+BEGIN_SRC python :exports code :results output
  for l1 in liste1:
      for l2 in liste2:
          operation auf l1, l2
#+END_SRC 


** Paarweise Operation: Beispiel 1 -- Summe der Produkte	   :subslide:

Berechne Summe der Produkte jedes Elements von Liste 1 mit jedem
Element von Liste 2 

#+BEGIN_SRC python :exports both :results output
  L1 = [1, 2, 3]
  L2 = [17, 18, 19]
  summe = 0
  for l1 in L1:
      for l2 in L2:
          summe += l1 * l2
  print(summe)
#+END_SRC 

#+RESULTS:
: 324

** Paarweise Operation: Beispiel 2 -- Test auf enthalten	   :subslide:

Innere Schleife abbrechen wenn Ergebnis feststeht 

#+BEGIN_SRC python :exports both :results output
  items = ["aaa", 111, (4, 5), 2.01]      # Eine Liste von Daten 
  tests = [(4, 5), 3.14]                  # Wonach suchen wir? 

  for key in tests:                       # Fuer alle zu suchenden Daten
      for item in items:                  # Fuer alle vorhandenen Daten 
          if item == key:                 # Gleich? 
              print(key, "gefunden in Daten")
              break                       # Brich die innere Schleife ab 
      else:
          print(key, "nicht in Daten")    # Nur ausgefuehrt wenn innere Schleife 
	                                  # nichts gefunden hat 
#+END_SRC 

#+RESULTS:
: (4, 5) gefunden in Daten
: 3.14 nicht in Daten


*** UEBUNG DAs geht mit ~in~ viel einfacher 

Recoding zu if key in items ; innere Schleife sparen 

*** UEBUNG Schnitt zweier Strings 

- Version 1: Mit geschachteleter SChleife 

- Version 2: Mit test per in

- Version 3: mit list comprehension 

#+BEGIN_SRC python :exports code :results output
[x for x in seq1 if x in seq2]
#+END_SRC 


** Beispiel mit geschachteltem ~range~ 

Berechne $\sum_{i=0}^{10} \sum_{j=0}^i i \cdot j$

#+BEGIN_SRC python :exports both :results output
  summe = 0
  for i in range(11):
      for j in range(i+1):
          summe += i*j
  print(summe)
#+END_SRC 

#+RESULTS:
: 1705

** Beispiel mit geschachteltem ~range~ und list comprehension	   :subslide:

#+BEGIN_SRC python :exports both :results output
  summe = sum([i*j
               # aeußere Schleife: 
               for i in range(11)
               # innere Schleife: 
               for j in range(i+1)
               ])
  print(summe)
#+END_SRC 

#+RESULTS:
: 1705

*** Eingebaute Funktion: ~sum~


Hilfsfunktion ~sum~: Addiere alle Elemente einer Aufzählung auf 

*** UEBUNG Geschachtelte for in list comprehensions 

ganz viele Übungen denkbar. 



** Beispiel: Sortieren 

- Gegeben: Eine Liste mit Zahlen 
- Gesucht: Eine Liste mit den gleichen Zahlen, aber aufsteigend
  sortiert

*** Idee: Suche die kleinste Zahl aus Restliste 

- Schritt 1: Suche die kleinste Zahl aus der ganze Liste
  - Vertausche mit Element am Anfang
- Schritt 2: Genauso, mit der Liste ab Position 2
- Usw. 

Sog. *Selection Sort* 


** Selection Sort: Vorüberlegung				   :subslide:

- Wie viele, welche Schleifen?
  - Eine Schleife, um das erste, zweite, ... Element zu bestimmen:
    ~for~
  - Um ein Element zu bestimmen, den Rest absuchen: noch eine ~for~,
    geschachtelt 

** Selection Sort: Code						   :subslide:

#+BEGIN_SRC python :exports both :results output
%%tutor -t
liste = [17, 1, 42, 99, 33]
for pos in range(len(liste)):
    tausch = pos
    for such in range(pos+1, len(liste)):
        if liste[such] < liste[pos]:
            tausch = such
    liste[pos], liste[tausch] = liste[tausch], liste[pos]

print(liste)
#+END_SRC 

#+RESULTS:
: [1, 17, 33, 42, 99]

*** Visualisierung						    :animate:

Abbildung [[fig:selection-sort]] visualisiert einen Zwischenstand beim
Ablauf von Selection Sort. 

#+CAPTION: Selection Sort
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:selection-sort
[[./figures/pt-selectionsort.png]]


** Sortieren in Python: Eingebaut				   :subslide:

- Niemand schreibt so eine Sortier-Funktion von Hand 
- Das ist als eingebaute Funktion verfügbar: ~l.sort()~ für eine Liste ~l~

** Beispiel: Mischen zweier Listen 

- Gegeben: Zwei sortierte Listen (beliebiger Länge) 
- Gesucht: Eine sortierte Liste, die die Elemente der beiden Listen
  enthält 

** Mischen: Vorüberlegung					   :subslide:

- Triviale Idee: Listen hintereinander kopieren, dann sortieren 
  - Verschwenderisch -- wir können die Sortierung der Listen ja
    ausnutzen 
- Bessere Idee: Gehe Listen Elementweise durch und nimm jeweils das
  kleinere Element 


** Mischen konventionell					   :subslide:

#+BEGIN_SRC python :exports both :results output
  a = [1, 3, 6, 9, 12, 23]
  b = [2, 4, 5, 10, 11, 17, 18]
  r = []

  aindex = 0
  bindex = 0

  while (aindex < len(a)) and (bindex < len(b)):
      print(aindex, bindex)
      if a[aindex] < b[bindex]:
          r.append(a[aindex])
          aindex += 1
      else:
          r.append(b[bindex])
          bindex += 1

  if aindex == 0:
      r.extend(b[bindex:])
  else:
      r.extend(a[aindex:])

  print("Resultat: ", r)
#+END_SRC 

#+RESULTS:
#+begin_example
0 0
1 0
1 1
2 1
2 2
2 3
3 3
4 3
4 4
4 5
5 5
5 6
Resultat:  [1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 17, 18, 23]
#+end_example


** Mischen mit Slicing						   :subslide:


#+BEGIN_SRC python :exports both :results output
  a = [1, 3, 6, 9, 12, 23]
  b = [2, 4, 5, 10, 11, 17, 18]
  r = []
  while (len(a) > 0) and (len(b) > 0):
      print(a, b) 
      if a[0] < b[0]:
          r.append(a[0])
          a = a[1:]
      else:
          r.append(b[0])
          b = b[1:]

  if len(a) == 0:
      r.extend(b)
  else:
      r.extend(a)

  print("Resultat: ", r)
#+END_SRC 

#+RESULTS:
#+begin_example
[1, 3, 6, 9, 12, 23] [2, 4, 5, 10, 11, 17, 18]
[3, 6, 9, 12, 23] [2, 4, 5, 10, 11, 17, 18]
[3, 6, 9, 12, 23] [4, 5, 10, 11, 17, 18]
[6, 9, 12, 23] [4, 5, 10, 11, 17, 18]
[6, 9, 12, 23] [5, 10, 11, 17, 18]
[6, 9, 12, 23] [10, 11, 17, 18]
[9, 12, 23] [10, 11, 17, 18]
[12, 23] [10, 11, 17, 18]
[12, 23] [11, 17, 18]
[12, 23] [17, 18]
[23] [17, 18]
[23] [18]
Resultat:  [1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 17, 18, 23]
#+end_example


** Beispiel: Binäre Suche 

- Gegeben:
  - Sortierte Liste mit Werte
  - Gesuchter Wert
- Gesucht:
  - Index des Wertes in Liste, falls vorhanden
  - Information, andernfalls

** Binäre Suche, Vorüberlegung					   :subslide:

- Liste linear absuchen?
  - Funktioniert, aber wir können Sortierung ausnutzen!
- Idee:
  - Prüfe Wert in der Mitte der
    - Falls gefunden: fertig
    - Wenn größer: Suche oben; wenn kleiner: suche unten
  - Wenn kein Wert mehr übrig, fertig 
- Welche Schleifen? 

** Binäre Suche, Code						   :subslide:

#+BEGIN_SRC python :exports both :results output
  l = [2, 4, 5, 10, 11, 17, 18]
  wert = 11
  gefunden = False
  unten = 0
  oben = len(l)

  while ((not gefunden) and
         (unten <= oben) and
         (unten < len(l))):
      mitte = int((unten+oben)/2)
      if l[mitte] == wert:
          gefunden = True
      elif l[mitte] < wert:
          unten = mitte + 1
      else:
          oben = mitte -1

  print(gefunden, mitte)

      
#+END_SRC 

#+RESULTS:
: True 4

*** Frage							    :animate:

Wozu braucht man die Schleifenbedingung ~unten < len(l)~ ?     

* Zusammenfassung

** Zusammenfassung 

- Wiederholte Ausführung von Anweisungen ist extrem nützlich 
- Unterschiedliche Kontrollmechanismen existieren 
  - ~while~-Schleife: Kontrolle durch einen Ausdruck, der
    Wahrheitswert liefert
  - ~for~-Schleife: In jeder Wiederholung nimmt eine (oder mehrere)
    Schleifenvariable einen Wert aus einer vorgegebenen Aufzählung an 
- Schleifen erlauben Ausnahmen (~break~, ~continue~) und Code für
  reguläres Ende (~else~)
- Zusammen mit ein paar Hilfsfunktionen (~range~, ~zip~) sind
  insbes. ~for~-Schleifen in Python extrem praktisch 


** Python-Keywords: Liste bis jetzt 

- Bis jetzt:
  - ~True~, ~False~, ~and~, ~or~,  ~def~,  ~return~, ~None~
  - ~in~
- Neu:
  - ~if~, ~else~, ~pass~, ~elif~, ~while~, ~for~, ~break~, ~continue~, ~assert~


** Python: eingebaute Funktionen 

- Allgemein 
  - ~print~, *~range~*, *~zip~*
- Typ-bezogen
  - ~len~
- Datentypen erzeugen
  - ~tuple~
  - ~list~
  - ~set~
  - ~dict~



* Notes								   :noexport:

- if 
- while 

später: 

- exceptions 
- yield , generators 
- assert 

noch später: 
- context managers 

* Weitere Übungen						   :noexport:

*** UEBUNG Zulassungsvoraussetzungen für Klausur prüfen 

Gegeben Liuste von Dicts. In jedem Dict steht Matrikelnummer, Anzahl
Vorrechnen, Liste mit Punkten pro Blatt. 

Prüfe Zulassung zur Klausur. REsultat: Liste mit True/False 

Testfall: Auch die leere Liste!! 


*** UEBUNG Wehrheim Folien 260 

*** UEBUNG Pascalsches Dreieck
