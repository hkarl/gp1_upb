#+TITLE: Kapitel 3: Werte, Namen, Bezeichner
#+INCLUDE: "../template/header.org"

#+STARTUP: showeverything

# TODO states: looks like this has to go on main file and cannot be
# included 
#+TODO: TODO(t) | UEBUNG(u) DONE(d)
#+OPTIONS: tasks:todo

#+LATEX_HEADER: \setcounter{chapter}{3}
* Überblick 



** Setup 						  :skipslide:nolatex:

Main point here is to set up warnings properly for presentation and to
load tutormagic, so that we can later on use pythontutor for code
animations. 
   
#+BEGIN_SRC  Python 
%load_ext tutormagic
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning, module='.*/IPython/.*')


import requests
import webbrowser
from IPython.core.magic import register_line_magic

pingo_token = "BRx9QJP7rjdUGBq3x4hP"

# Test-Session: 
pingo_url = "https://pingo.upb.de/events/311055/quick_start.json"
# Produktiv-Session: 
# pingo_url = "https://pingo.upb.de/events/204051/quick_start.json"

pingo_duration = '120'
pingo_type = "single"


@register_line_magic
def pingo(line):
    params = {'survey_name': pingo_title, 
              'predef_options': pingo_questions, 
              'q_type': pingo_type,
              'duration': pingo_duration, 
              'auth_token': pingo_token}

    r = requests.post(pingo_url, json=params)
    webbrowser.open_new_tab("https://pingo.upb.de" + r.headers['Location'])
#+END_SRC


** Dieses Kapitel 

- Bisher nur Ausdrücke, die keine Zustandsänderung bewirken 
- Dieses Kapitel: Konzept von /Namen/ und /Bezeichnern/ -- das Benennen eines Werts
- Erlaubt Weiterverwendung und Manipulation von Ergebnissen eines
  Ausdrucks 


* Namen, Bezeichner  


** Ausdrücke sind vergesslich 

- Bisher: Nur Literale und Ausdrücke 
- Wert eines Ausdrucks nach Berechnung sofort wieder vergessen  

- Unpraktisch! 

*** Aufheben?							    :animate:

- Wie können wir den Wert eines Ausdrucks aufbewahren?
- Wie können wir den Wert wieder benutzen? 

** Namen! 

- Wir brauchen einen *Namen* für einen Ausdruck
- Mit Namen dann wieder benutzbar 

#+NAME: fig:vader-ring 
#+CAPTION: If you like it, you should put a name on it
#+ATTR_LaTeX: :width 0.25\linewidth
[[./figures/vader-ring.png]]


** Namen -- Beispiel 

- Wir benutzen einfachen Namen: ~a~
- Der Name ~a~ wird dem Wert 42 zugeordnet
- Dazu nutzen wird das Zeichen ~=~
- *Zuweisung* (*Assignment*)

#+BEGIN_SRC python
# a wird zu einem Namen für den Wert 42
a = 42
#+END_SRC


** Zuweisung (v1) 


*** Zuweisung (v1) 					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Bei einer *Zuweisung* wird ein *Name* mit einem *Wert* verbunden.  

*** Schreibweise 

- Zuweisung wird durch ein Gleichheitszeichen angegeben
- Links davon: der Name
- Rechts davon: der Wert 


** Zuweisung: Im Detail 

- Die Zuweisung *erzeugt* den Wert, falls er noch nicht existiert 
- Die Zuweisung *erzeugt* den Namen, falls er noch nicht existiert 
- Die Zuweisung *verbindet* Namen mit Wert
  - Oder: *bindet* Namen an Wert, Name *ist gebunden an* Wert, Name
    *bezieht sich auf* Wert  

*** Zustandsänderung! 

- Eine Zuweisung ändert den Zustand des laufenden Programms 


*** Wert erzeugen?						  :dropslide:

Die Formulierung, einen Wert zu /erzeugen/, ist für das hier gewählte
Beispiel ggf. missverständlich -- inwieweit kann oder muss die Zahl 42
erzeugt werden; die existiert doch an sich? 

Das stimmt; die Zahl 42 wird nicht erzeugt. Genauer wäre zu sagen,
eine Repräsentation der Zahl 42 wird im Speicher des Rechners
erzeugt. Es wird eine freie Stelle im Speicher gefunden, an der (unter
anderem) ein Bitmuster abgelegt wird, das als die Zahl 42
interpretiert wird. 

Bei einer Zeichenkette ist das schon deutlicher. Diese muss erst
explizit im Speicher erzeugt werden, bevor sie mit einem Namen
versehen werden kann.   Ähnlich bei arithmetischen Ausdrücken: Auch
hier muss zunächst der Wert berechnet werden, bevor der Namen an den
(berechneten) Wert gebunden werden kann. 

Bei komplexeren Datentypen (siehe folgende
Kapitel) ist dies ebenso der Fall: der Wert muss in der Regel erst
erzeugt werden. Wir kommen darauf noch zurück.




** Zuweisung: Namen sind Schilder an Werten 

Binden: An den Wert ein Namensschild hängen 

*** Code 

#+BEGIN_SRC python
# a wird zu einem Namen für den Wert 42
a = 42
#+END_SRC

*** Konzept 

#+NAME: value-a-42
#+CAPTION: Der Name a  verweist auf  den Wert 42
#+ATTR_LATEX: :width 0.3\textwidth :float nil
[[file:figures/namesLabels.png]]




** Und was ist mit Variablen?

- Sonst doch immer: *Variable*?
  - Statt Wert und Name?
- Ja, in anderen Sprachen! (z.B. C, Java, ...)
  - Dort: Variable ist ein *Name* für eine *Speicherstelle* (eine
    *Adresse*)
    - *Nicht* für einen Wert 
  - (plus Typ, plus Gültigkeitsbereich, plus Lebensdauer) 
  - Speicherstelle enthält dann  *Wert*
- Eine *benannte Schuhschachtel*


*** Schilder an Werten oder Boxen mit Aufschrift?		  :dropslide:

Wenn Sie schon mit anderen Programmiersprachen wie etwa Java vertraut
sind, ist die Vorstellung, ein Variablenname ist ein Namensschild für
einen Wert möglicherweise befremdlich. Dort ist die typische
Vorstellung eher: Eine Variable ist eine Schuhschachtel (mit einem
Namen), in die ein Wert gelegt wird.

Auf den ersten Blick macht das vielleicht keinen großen
Unterschied. Tatsächlich ist dies ein relativ fundamentaler
Unterschied, wie Programmiersprachen funktionieren.  Im Detail ist die
Vorstellung von Variablen (insbes. eine typisierte Variable) 
relativ kompliziert. Das Name/Wert ist eigentlich einfacher, aber
ggf. zunächst kontraintuitiv wenn man schon eng mit der Speicherung
von Daten in einer typischen Rechnerarchitektur vertraut ist. 


Für das Speichermodell von Python ist die Namensschild-Analogie
passender. Details werden wir im Kapitel zu veränderlichen Datentypen
besprechen (und auch in der folgenden Vorlesung /Grundlagen der
Programmiersprachen/).



** Variablen in Python? 

*** KEINE Variablen in Python                                  :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Es gibt in Python keine Variablen 


*** ... nur aus Versehen                               :B_alertblock:animate:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Falls mir doch einmal /Variable/ herausrutscht, ist das *falsch*!
Protestieren Sie lautstark! 

Gemeint: 
- wenn Variable *rechts* von ~=~: ein Name, der an einen Wert gebunden *ist*
- wenn Variable *links* von ~=~: ein Name, der an einen Wert gebunden *wird*


    
** Gültige Namen -- Bezeichner? 

- ~a~ war ein Beispiel für einen Namen
- Wie darf ein Name überhaupt aussehen?

*** Bezeichner                                                 :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

- Ein /Bezeichner/ (oder /identifier/) ist eine nichtleere
  Zeichenkette beliebiger Länge, bestehend aus Klein- oder
  Großbuchstaben, Ziffern, oder dem Unterstrich ~_~

- Das erste Zeichen hat Sonderrolle:

  - Es darf keine Ziffer sein

  - Unterstrich ~_~ als erstes Zeichen hat besondere Bedeutung
    (später) 

- Groß-/Kleinschreibung ist wichtig 

- Einige Zeichenketten sind für andere Zwecke /reserviert/

** Gültige und ungültige Bezeichner: Beispiele 

- Gültig: ~hallo~, ~x1~, ~_a_b~
  - Gültig, aber unterschiedlich: ~a~, ~A~, ~var1~, ~Var1~ 
- Ungültig: ~1x~, ~x-y~, Sonderzeichen in Namen ($, # , ...) 



** Reservierte Zeichenketten

- Manche Zeichenketten haben Sonderrolle, dürfen nicht als Bezeichner benutzt werden 
- Beispiel: Literale ~True~, ~False~
  - ~True~ als Name benutzbar?
    - ~True = False~ ???
    - *Nein!* 

*** Schlüsselwort					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Ein /Schlüsselwort/ (reserviertes Wort, reservierter Name, key word)
ist ein Zeichenkette, die in einer Programmiersprache eine Sonderrolle
einnimmt. Ein Schlüsselwort darf /nicht/ für andere Zwecke benutzt
werden, z.B. als Bezeichner.

Jede Programmiersprache hat eine Liste von Schlüsselworten. 



** Python-Schlüsselworte bis jetzt 				   :subslide:

- ~True~, ~False~
  - Achtung: ~True~, nicht ~true~!
  - Groß-/Kleinschreibung wichtig bei Schlüsselworten! 
- ~and~, ~or~


** Sinnvolle Namen? 

Ist ~a~ ein sinnvoller Name? 

- Für eine Folie mit einem Namen: naja
- Für ein größeres Programm: Nein!
  - Nutzen Sie sog. *sprechende Namen*: Namen, denen man den Zweck,
    Inhalt, Benutzung leicht ansieht
    - Gut: ~eingabedatei~, ~quersumme~, usw. 
    - Schlecht: ~ii2~, ~x_17_b~ 
- Sie müssen Ihr Programm auch in drei Monaten noch selbst verstehen! 


** Namenskonvention 




*** Namenskonvention					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Eine *Namenskonvention* beschreibt übliche Vorgehensweisen zur Wahl
von Namen. Sie schränkt die möglichen Namen auf die sinnvollen Namen
ein, ist aber kein formaler Bestandteil der Sprache. 

*** Pythons Namenskonvention für Werte                    :B_example:animate:
    :PROPERTIES:
    :BEAMER_env: example
    :END:

- Kleinbuchstaben am Anfang
- Namen aus mehreren Worten werden durch Unterstrich getrennt 
- Vermeide: kleines l, großes O und großes I -- Verwechselungsgefahr 
- (Namen für andere Zwecke, andere Konventionen -- siehe später) 


** Namen nutzen

- Wie bekomme ich den mit Namen verbundenen  Wert? 
- Einfach: Namen  als Ausdruck benutzen

#+BEGIN_SRC python
a = 5
a + 17
#+END_SRC


** Mehrere Namen   

*** Code 

#+BEGIN_SRC python
# a und b werden zu Namen für Wert 42 
a = 42
b = 42
#+END_SRC

*** Konzept 

#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400 
#+header: :cache yes
#+begin_src latex :exports results :results output raw :file figures/TwoNamesLabels.png :fit t
    \usetikzlibrary{arrows,positioning,decorations.pathmorphing}
    \begin{tikzpicture}
    [pyvariable/.style={rectangle,draw=black,thick},
     pyvalue/.style={rectangle,draw=black,fill=black!10,thick}]
    \node[pyvariable] (vara)  at (0,0) {a};
    \node[pyvariable] (varb)  at (0,-2) {b};
    \node[pyvalue] (val42) at (2,-1) {42};
    \draw [->,red,decorate,decoration=snake] (vara.east) -- (val42.170);
    \draw [->,red,decorate,decoration=snake] (varb.east) -- (val42.190);
    \end{tikzpicture}
#+end_src

#+NAME: value-a-and-b
#+CAPTION: Beiden Namen a und b sind an  den Wert 42 gebunden 
#+ATTR_LATEX: :width 0.3\textwidth :float nil
#+RESULTS[eaae2c4b0d77c7a6883b00efcd02b0a543d9ff83]:
[[file:figures/TwoNamesLabels.png]]


** Mehrere Namen  -- Beobachtungen 

*** Namen und Werte

- Zwei unterschiedliche Namen für den gleichen Wert!
  - Dem Wert ist das egal; die Zahl 42 ist immer die gleiche

*** Syntaxregel 						    :animate:

- Mehrere Anweisungen: *Eine Zeile, eine Anweisung* 

*** UEBUNG Lange Anweisung 

Wie kann man eine Anweisung aufschreiben, die länger als eine Zeile
ist? 

- Ganz lange Zeile (mit *scheinbarem* Umbruach)
- Zwischenergebnisse einführen
- Syntax erweitern; continuation
  - Explizit durch backslsh
  - IMplzit durch Klammerregeln 


** Weitere Zuweisung 

*** Code 

#+BEGIN_SRC python
a = 42
b = 42
# Name a wird an einen neuen Wert gebunden 
# (sog. "rebinding") 
a = "Hallo"
#+END_SRC

*** Konzept 

#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400 
#+header: :cache yes
#+begin_src latex :exports results :results output raw :file figures/abHallo.png :fit t
    \usetikzlibrary{arrows,positioning,decorations.pathmorphing}
    \begin{tikzpicture}
    [pyvariable/.style={rectangle,draw=black,thick},
     pyvalue/.style={rectangle,draw=black,fill=black!10,thick}]
    \node[pyvariable] (vara)  at (0,0) {a};
    \node[pyvariable] (varb)  at (0,-2) {b};
    \node[pyvalue] (val42) at (2,-1) {42};
    \node[pyvalue,text=blue] (valstr) at (2,0) {``Hallo''};
    \draw [->,blue,decorate,decoration=snake] (vara.east) -- (valstr.west);
    \draw [->,red,decorate,decoration=snake] (varb.east) -- (val42.west);
     \end{tikzpicture}
#+end_src

#+NAME: value-abHallo
#+CAPTION: Name a wird an  einen neuen Wert gebunden 
#+ATTR_LATEX: :width 0.3\textwidth  :float nil
#+RESULTS[8506a1af9f236c7594993875c314053271386e0a]:
[[file:figures/abHallo.png]]








* Arbeiten mit Namen und Zuweisungen 


** Namen an Namen zuweisen 

Geht das? Wert von b? 

#+BEGIN_SRC python
%%tutor  
a = 42
b = a
#+END_SRC

*** Semantik von Zuweisung: *Wert* 

- Das ist nur ein Sonderfall!
- Allgemein:
  - Wert des Ausdrucks auf der rechten Seite bestimmen
  - Namen links von ~=~ wird zu Namen für diesen Wert
  - Egal, ob der Ausdruck rechts ein Namen, Ausdruck, ... ist -- es
    geht um *den Wert* 


** Animationen von Programmen 

- Die vorherige Folie war auch ein Beispiel für Programmanimationen
  - Web-Anwendung: [[http://www.pythontutor.com/][PythonTutor]]
  - Erlaubt Ausführung von Programmen in Einzelschritten und Anzeige
    der an Namen gebundenen Werte 
- Sie können das selbst nutzen
  - direkt auf Webseite von PythonTutor 
  - oder aus den Jupyter-Notebooks heraus: mit ~%%tutor~ in
    der ersten Zeile
  - aus dem Skript heraus: Links [[http://www.pythontutor.com][(PT link)]]

*** Pythontutor-Links im Skript 				  :dropslide:

Wenn Sie im Skript (PDF-Datei) auf ein Code-Beispiel stoßen, bei dem
unter dem Quellcode (PT link) steht, so ist dies ein Link auf das
Beispiel in Pythontutor. Wenn Sie auf diesen Link klicken,
sollte sich ein Browser-Fenster öffnen, das auf die Webseite von
Pythontutor zeigt und wo das entsprechende Code-Beispiel bereits
eingetragen ist. 

Sie können dort das Code-Beispiel noch editieren oder direkt auf den
Knopf /Visualize Execution/ unterhalb des Editier-Fensters drücken
(Abbildung [[fig:pt-edit]]).

#+CAPTION: PythonTutor: Editier-Ansicht
#+ATTR_LaTeX: :width 0.75\linewidth
#+ATTR_LaTeX: :caption \caption{PythonTutor: Editier-Ansicht \label{fig:pt-edit}}
#+NAME: fig:pt-edit
[[./figures/pt-edit-screen.png]]

 

Danach kommen Sie zu einer zweiten Ansicht, in der Sie durch Forward
und Backward das Programm in einzelnen Schritten ausführen können
(Abbildung [[fig:pt-run]]). Links werden die jeweils auszuführenden
bzw. gerade ausgeführte Anweisung durch rote bzw. grüne Pfeile
angezeigt. Rechts sieht man die an Namen gebundenen Werte.

#+CAPTION: PythonTutor: Ausführungs-Ansicht
#+ATTR_LaTeX: :width 0.75\linewidth
#+ATTR_LaTeX: :caption \caption{PythonTutor: Ausführungs-Ansicht \label{fig:pt-run}}
#+NAME: fig:pt-run
[[./figures/pt-start-screen.png]]




** Animationen von Programmen -- Quellcode 

*** Kein tutor in normalen Programmen 			       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Die Anweisung ~%%tutor~ in der ersten Zeile einiger der
Programmbeispiele hier ist eine JupyterNotebooks-Eigenheit.  Sie dient
dazu, das Notebook mit der Web-Anwendung PythonTutor zu
verknüpfen. Leider werden diese in die Ausgabe des Skriptes mit
übernommen. 


Übernehmen Sie diese Zeile *nicht*, wenn Sie das Programm ausserhalb
eines Notebooks (z.B. in einem Terminal-Fenster) ausführen wollen.


*** PythonTutor: Typische Anzeige				  :dropslide:

#+CAPTION: Screenshot PythonTutor
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:pythonTutor
[[./figures/pythonTutor1.png]]

Abbildung [[fig:pythonTutor]] ist ein typisches Beispiel der Anzeigen von
PythonTutor. 

- Auf der linken Seite wird das Programm angezeigt
  - Der rote Pfeil zeigt auf die Anweisung, die als nächstes
    ausgeführt wird (sobald man auf den Forward-Knopf drückt).
  - Der grüne Pfeil weist auf die Zeile hin, die gerade ausgeführt
    wurde und die den momentan angezeigten Zustand erzeugt hat.
- Auf der rechten Seite wird eben dieser Zustand angezeigt. Die rechte
  Seite hat zwei Spalten:
  - Links die sog. Frames; bis jetzt haben wir nur einen einzigen
    (Details später). Hier sind die bisher bekannten Namen aufgeführt. 
  - Rechts die Werte (hier als Objects bezeichnet; mehr dazu später).
  - Pfeile zeigen von den Namen auf die referenzierten Werte.





** FALSCH: Name auf Name 

*** ~b = a~ ist kein Name für ~a~ 			       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

Durch die Zuweisung ~b = a~ wird *KEIN* neuer Name für ~a~
vereinbart. ~b~ wird zu einem weiteren Namen für den Wert, der von ~b~
referenziert wird. 


*** FALSCH (*KOMPLETT ABSURD*): 

#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400 
#+header: :cache yes
#+begin_src latex :exports results :results output raw :file figures/wrongLabels.png :fit t
    \usetikzlibrary{arrows,positioning,decorations.pathmorphing}
    \begin{tikzpicture}
    [pyvariable/.style={rectangle,draw=black,thick},
     pyvalue/.style={rectangle,draw=black,fill=black!10,thick}]
    \node[pyvariable] (vara)  at (0,0) {a};
    \node[pyvariable] (varb)  at (0,-2) {b};
    \node[pyvalue] (val42) at (2,-1) {42};
    \draw [->,decorate,decoration=snake] (vara.east) --
    (val42.170); 
    \draw [->,decorate,decoration=snake] (varb.north) --
    (vara.south);
    \draw[red, very thick] (-1, -2) -- (3, 0.5);
    \draw[red, very thick] (-1, 0.5) -- (3, -2);
    \end{tikzpicture}
#+end_src

#+NAME: wrongLabels
#+CAPTION: Vorsicht falsch: ~b~ wird *nicht* zu Namen für ~a~
#+ATTR_LATEX: :width 0.3\textwidth :float nil
#+RESULTS[6950e4cfb75c232dda4bb997dc59d87f76010e7a]:
[[file:figures/wrongLabels.png]]


** Einen Namen verändern? 

- Genauer: Ein Name referenziert einen neuen Wert 
- Wert von ~b~? 

#+BEGIN_SRC python
%%tutor  
a = 5
b = a
a = a + 2
b 
#+END_SRC

** Warum hat ~b~ den Wert 5?  

1. ~a = 5~ : Name ~a~ referenziert den Wert 5
2. ~b = a~ : Der Wert des Ausdrucks auf der rechten Seite wird
   bestimmt. Name  ~b~ wird zu einem Namen für diesen Wert. 
3. ~a = a + 2~ : 
   1. ~a + 2~ ausrechnen, ergibt Wert 7
   2. Der Wert 7 wird im Speicher repräsentiert 
   3. ~a~ wird zu einem Namen für diesen Wert
4. ~b~ ist immer noch ein Name für 5
   1. Warum sollte sich hier etwas geändert haben?


** Ausdrücke  mit Namen  

- In Ausdrücken können Namen  wie Werte benutzt werden
- Genauer: Bei Berechnung des Ausdrucks wird Name durch gebundenen Wert
  *ersetzt*
  - Wie Beispiel oben: ~b = a~ 
- Name links von ~=~ wird zu Namen für berechneten Wert 

*** Beispiele 

#+BEGIN_SRC python
a = 17 + 5 
b = 3*a +5 
c = (a + b)/5
#+END_SRC


** Beispiel: Wert von ~y~ am Ende? 


#+BEGIN_SRC python :exports source :results output
x = 42
y = x
x = 42 - y
y = 2*x + 17
#+END_SRC

#+RESULTS:
: 17


*** Pingo						    :animate:nolatex:
#+BEGIN_SRC python :exports code
pingo_title = "Wert von y?" 
pingo_type = "single"
pingo_questions = ["42", "0", "-42", "17"]

%pingo
#+END_SRC 


** Beispiel: Gebundene Werte zweier Namen vertauschen 

Wie vertauschen Sie die Werte zweier Namen? 

#+BEGIN_SRC python
a = 17 
b = 42 
# Your code here 
... 
#+END_SRC

*** UEBUNG Namens-Werte tauschen ohne Hilfsvariable; xor 

Üblicher xor-Trick 


** Gleichzeitig Zuweisungen 

Python: *Gleichzeitige* Zuweisung an mehrere Namen möglich 

*** Syntax 

- Links von ~=~: Mehrere Namen, durch Komma getrennt 
- Rechts von ~=~: Mehrere Ausdrücke, durch Komma getrennt 
- Anzahl stimmt überein
  - Siehe später, /unpacking/ 
- Beispiel mit drei Ausdrücken: 

#+BEGIN_SRC python
a, b, c = Ausdruck1, Ausdruck2, Ausdruck3 
#+END_SRC

** Gleichzeitige Zuweisungen -- Semantik 

1. *Alle* Ausdrücke auf der rechten Seite werden ausgewertet
   1. Dabei werden noch die *ursprünglichen* Werte benutzt (es gibt ja
      noch keine anderen)
2. *Danach* werden alle Zuweisungen zu den neu berechneten Werten
   hergestellt
3. Erst wenn *alle* Zuweisungen fertig sind, geht es weiter 

Formal: *atomare* Zuweisungen 

** Gleichzeitige Zuweisungen -- Beispiele 

#+BEGIN_SRC python
x, y = 17, 42
x, y = 2*x, y-5 
#+END_SRC

*** Vertauschen zweier gebundener Werte? 

#+BEGIN_SRC python
x, y = 17, 42
# ??? 
#+END_SRC



** Zuweisung (v2) 


*** Zuweisung (v2) 					       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Bei einer Zuweisung werden ein oder mehrere *Namen* mit einem oder
mehreren Werten verbunden.  Der Name *bindet an* den entsprechenden
Wert. 

*** Schreibweise 

- Zuweisung wird durch ein Gleichheitszeichen angegeben
- Links davon: der oder die *Namen*, durch Komma getrennt
- Rechts davon: der oder die *Asudrücke*, durch Komma getrennt 



** Kurzschreibweisen bei Zuweisungen 

- Häufig: an Namen einfachen arithmetischen Ausdruck aus diesem
  Namen zuweisen
  - ~x = x + 1~, ~y = y / 2~
- Dafür Kurzschreibweise:
  - ~Name Operator= Ausdruck~
  - Entspricht: ~Name = Name Operator Ausdruck~
- Beispiele
  - ~x += 1~
  - ~y /= 2~

* Zuweisungen und Typen 

** Typen? 

- Werte und Ausdrücke haben Typen 
- Name? Verweist lediglich  auf  Wert
- *Typ des Names*: Typ des zugewiesenen Werts
  - Welcher Typ sollte es auch sonst sein?? 


** Typ eines Namens veränderlich? 

Heißt das, dass sich der Typ eines Namens verändern kann? 

- *JA*! 

#+BEGIN_SRC python
x = 42
# Typ von x: int
x = 'Hallo GP1'
# Typ von x: str
#+END_SRC


** Wo ist der Typ? 

- Typ-Information liegt *nicht* beim Namen
  - Für einen Namen  *muss kein Typ angegeben werden*
  - Es wäre auch sinnlos, das zu tun
- Typ-Information liegt beim gebundenen Wert  
- Ist dort aber *explizit bekannt*! 


** Problem? 

- Dem Interpreter ist das egal -- die Typinformation ist ja vorhanden 
- Ein Programmierer sieht einem Namen (zunächst) nicht an, auf was der
  Name verweist 
  - Das kann sich ja ändern
  - Das erfordert Disziplin! 
- Idee: /Solange der Wert weiß, was er ist, ist alles gut/

** Dynamisch typisierte Sprache 

*** Dynamisch typisierte Programmiersprache		       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Eine Programmiersprache ist */dynamisch typisiert/*, wenn
Typen-Informationen für jeden Namen, Wert oder Ausdruck *zur Laufzeit* bekannt
sind. Diese Typen-Information ist im Programm-Code nicht explizit
repräsentiert und nicht notwendigerweise aus ihm ableitbar. 


Python ist ein Beispiel. 

** Statisch typisierte Sprache 

*** Statisch typisierte Sprache				       :B_definition:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Eine Programmiersprache ist */statisch typisiert/* wenn
Typen-Information für */Namen/* (bzw. Variablen) explizit im
Programm-Code angegeben werden muß. Aus der Betrachtung des
Programm-Codes kann der Typ eines Wertes abgeleitet werden, bereits
bevor das Programm selbst abläuft.

Gegebenenfalls wird in einer solchen Sprache auf die explizite
Repräsentation des Typs eines Wertes /zur Laufzeit/ verzichtet, da ja
alle Informationen bereits vorab bekannt sind. (In OO-Sprachen meist
doch vorhanden.)


Java ist ein Beispiel (aber eigentlich eine Mischform). 

*** Historie							  :dropslide:

Eine nette Zusammenfassung der Geschichte dahinter findet sich in
[[http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html][diesem Blog]]. 




* Anmerkungen zu Syntax und Stil 

** Syntax 

Einige aufgetauchte Syntaxregeln: 

- Formulierung von Literalen und Ausdrücken 
- Kommentare beginnen mit # 
- Eine Anweisung, eine Zeile 
- Anweisungen mit Gleichheitszeichen schreiben
  - Und gleichzeitige Anweisungen mit Komma trennen 

** Syntax: Formalisierung 

- Syntaxregeln durch /formale Sprachen/ und Grammatiken  formalisiert 
- Visualisiert: Syntaxdiagramme 
- Beispiele: Später 

** Stil 

- Syntax: Harte Regeln, *müssen* eingehalten werden 
- Aber mit Spielraum 
  - Beispiel: Leerzeichen vor, nach ~=~, Klammern?
- Unterschiedliche Interpretation von Spielraum? 
  - Verwirrt, senkt Lesbarkeit, erschwert Wiederbenutzung
  - /Code wird öfter gelesen als geschrieben!/
- Daher: *Stilregeln* (*/style guides/*) für /*Konsistenz*/
  - Anfänger-Code = inkonsistenter Code 



** Schlechter Stil ist peinlich 

#+CAPTION: Code ist kein Salatrezept
#+ATTR_LaTeX: :width 0.75\linewidth :float nil
#+NAME: fig:salatrezept
[[./figures/code_quality.png]]


** Stilregeln Python 

- Python: festgelegte Stilregeln
  - Python Enhancement Proposal No. 8 ([[https://www.python.org/dev/peps/pep-0008/][PEP 8]])
- Beispiele:
  - Maximale Zeilenlänge 79 Zeichen
  - Leerzeichen
    - Nach Komma, nicht davor
    - Nicht nach öffnender oder vor schließender Klammer
    - Genau ein Leerzeichen vor und nach Zuweisung 
    - Stimmt mit Buchsatzregeln überein!

** Stilregeln in Python: Beispiel Kommentare 

- Beginne mit #, gefolgt von einem Leerzeichen
- Schreibe englisch 

- Auch: Empfehlungen zu Struktur der Kommentare 

***  Sinnlos: Offensichtliches 
#+BEGIN_SRC  python 
x = x + 1   # Erhoehe x um 1 
#+END_SRC

*** Sinnvoll: /Grund/ für die Anweisung 
#+BEGIN_SRC python 
x = x + 1   # Platz am Rand lassen 
#+END_SRC


** Stilregeln in Python 

- Aber: es sind Regeln -- keine Regel ohne Ausnahme 

- Selbst nachdenken, nachfragen, eigenes Urteil 

- [[https://www.python.org/dev/peps/pep-0020/][PEP 20 -- The Zen of Python]]

  - /*Beautiful is better than ugly.*/

  - /*Readability counts.*/


*** UEBUNG Leerzeichen 

Ein paar Beispiele für gute und schlechte Leerzeichennutzung 

*** UEBUNG Leerzeichen in arithmetischen Ausdrücken 

Warum empfiehlt PEP8 Leerzeichen um Operatoren mit niedriger
Priorität? 


*** UEBUNG Zeilenumbruch 

In vorheriger Übung haben Sie über lange Zeilen
nachgedacht. Angenommen, Sie müssen innerhalb eines arithmetischen
Ausdrucks umbrechen. Line break vor oder nach binärem Operator? 

Warum? Referenz? 

Lösung: PEP 8! (wo sonst...) 

* Zusammenfassung

** Zusammenfassung 

- Zuweisungen geben Werten einen /Namen/, haben die Form eines /Bezeichners/
- Damit ändert sich der /Zustand/ eines laufenden Programms 
- Regeln, wie Bezeichner aussehen dürfen  
- Die Repräsentation des Typs im Programmtext/zur Laufzeit
  unterscheidet dynamisch von statisch typisierten Programmiersprachen 



** Rückblick 

Waren Sie überrascht? 
- Gute Programmiersprache: Keine Überraschungen
- /Principle of least possible surprise/

Hätten Sie etwas anders gemacht? 
- Idealerweise: *Eine* offensichtliche Lösung 
- /*There should be one -- and preferably only one -- obvious way to do
  it.*/ ([[https://www.python.org/dev/peps/pep-0020/][PEP 20 -- The Zen of Python]]) 


* Notes								   :noexport:

- Bezeichner 
  - ERzeugung
  - Typ
  - Nutzung 

** Gemeinsame Referenzen -- Gleichheit 

 aber das macht erst bei mutables Sinn zu unterscheiden? is vs. == ? 
1
